<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1D Fluid Dynamics Analogue Simulator v23</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN for plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <!-- MathJax Configuration (IMPORTANT for inline LaTeX) -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']] // Configure $ for inline math
          },
          svg: {
            fontCache: 'global' // Optimize font loading
          },
          options: {
            // Explicitly tell MathJax to skip script tags to prevent parsing JavaScript as LaTeX
            skipHtmlTags: ['script', 'noscript', 'textarea', 'pre', 'code', 'annotation', 'annotation-xml'],
            ignoreHtmlClass: 'no-mathjax' // Also ignore elements with this class
          }
        };
    </script>
    <!-- MathJax CDN for LaTeX rendering -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Custom styles for better slider appearance */
        input[type='range']::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4F46E5; /* Indigo-600 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3); /* Indigo-600 with opacity */
            margin-top: -6px; /* Adjust to center thumb on track */
        }
        input[type='range']::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4F46E5;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3);
        }

        /* Dynamic gradient for the slider track */
        input[type='range'] {
            -webkit-appearance: none; /* Override default browser styles */
            appearance: none;
            width: 100%;
            height: 4px; /* Height of the track */
            border-radius: 2px;
            outline: none; /* Remove focus outline */
            background: linear-gradient(to right,
                hsl(120, 60%, 85%) 0%,    /* Light Pastel Green */
                hsl(210, 70%, 75%) 33%,   /* Pastel Blue */
                hsl(270, 80%, 65%) 66%,   /* Pastel Purple */
                hsl(0, 90%, 55%) 100%     /* Pastel Red */
            );
            background-size: var(--slider-value-percent, 0%) 100%; /* Controls the fill amount */
            background-repeat: no-repeat;
            background-color: #E0E7FF; /* Color for the unfilled part of the track */
            transition: background-size 0.1s ease-out; /* Smooth transition for the gradient fill */
        }

        /* Ensure the actual track part is transparent so the input's background shows */
        input[type='range']::-webkit-slider-runnable-track {
            background: transparent;
        }
        input[type='range']::-moz-range-track {
            background: transparent;
        }

        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3Csvg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem; /* Make space for the icon */
        }

        /* Modal specific styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            backdrop-filter: blur(5px); /* Blur background */
            -webkit-backdrop-filter: blur(5px); /* Safari support */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto; /* Center vertically and horizontally */
            padding: 20px;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
            position: relative;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            animation: fadeIn 0.3s ease-out;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 20px;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Spinner for activity indicator */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Pulsing color animation for text/icon */
        @keyframes pulseColor {
            0% { color: white; }
            50% { color: #FECACA; } /* Tailwind red-200 */
            100% { color: white; }
        }

        .pulsing-text {
            animation: pulseColor 1s ease-in-out infinite;
        }

        /* Activity Indicator Positioning */
        #simulationActivityIndicator {
            display: none; /* Hidden by default */
            position: absolute;
            top: 1.5rem; /* Adjust as needed to align with title */
            right: 1.5rem; /* Adjust as needed */
            z-index: 10;
            display: flex; /* Use flexbox for alignment of spinner and percentage */
            align-items: center;
            gap: 0.5rem; /* Space between spinner and percentage */
        }

        /* Adjusted progress bar to end before spinner */
        #progressBar {
            position: absolute; /* Needs to be absolute to control its right edge */
            left: 0;
            top: 0;
            height: 100%; /* Fill the parent container */
            border-radius: 9999px; /* Tailwind rounded-full */
            background-color: #4F46E5; /* Indigo-600 */
            transition: width 0.1s ease-out;
        }
        .progress-bar-container {
            position: relative; /* Make this the positioning context for the absolute progress bar */
            width: 100%;
            height: 0.625rem; /* h-2.5 */
            background-color: #E0E7FF; /* bg-gray-200 */
            border-radius: 9999px; /* rounded-full */
            margin-bottom: 1.5rem; /* mb-6 */
            overflow: hidden; /* Hide overflow of the inner bar */
        }

        /* Styling for the blue and red slashes */
        .slash-blue {
            color: #3B82F6; /* blue-500 */
        }
        .slash-red {
            color: #EF4444; /* red-500 */
        }
        .text-green-600-custom {
            color: #16A34A; /* This is Tailwind's green-600 */
        }
        .text-red-600-custom {
            color: #DC2626; /* This is Tailwind's red-600 */
        }
        .spinner.spinner-completed {
            animation: none; /* Stop the spin animation */
            border-top-color: #10B981 !important; /* Ensure all borders are green-600 */
            border-left-color: #10B981 !important;
            border-right-color: #10B981 !important;
            border-bottom-color: #10B981 !important;
        }

        /* Dynamic Tooltip styles */
        #dynamicTooltip {
            position: absolute;
            background-color: rgba(31, 41, 55, 0.95); /* Gray-800 with opacity */
            color: white;
            padding: 0.5rem 0.75rem; /* p-2 px-3 */
            border-radius: 0.375rem; /* rounded-md */
            font-size: 0.75rem; /* text-xs */
            line-height: 1rem; /* leading-tight */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-lg */
            white-space: normal; /* Allow text to wrap */
            max-width: 250px; /* Limit tooltip width */
            z-index: 2000; /* Ensure it's above everything else */
            pointer-events: none; /* Do not block mouse events on elements below */
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            transform: translate(-50%, -110%); /* Adjust position relative to cursor */
        }
        #dynamicTooltip.show {
            opacity: 1;
        }

        /* Fixed table layout for Live Data Points table */
        #detailedDataTableContainer table {
            table-layout: fixed;
        }
        #detailedDataTableContainer th,
        #detailedDataTableContainer td {
            width: 50%; /* Distribute width equally between two columns */
        }
    </style>
</head>
<body class="bg-gray-50 font-sans antialiased text-gray-800 p-4 sm:p-6">

    <div class="max-w-7xl mx-auto bg-white shadow-lg rounded-xl p-6 sm:p-8 border border-gray-200" id="mainContentArea">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center text-indigo-700 mb-2">1D Fluid Dynamics Analogue Simulator</h1>
        <p class="text-center text-sm text-red-600 font-semibold mb-8">
            (A 1D Reaction-Diffusion PDE model for conceptual exploration)
        </p>

        <!-- IMPORTANT DISCLAIMER FOR RESEARCH CONTEXT -->
        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md relative mb-8 text-center" role="alert">
            <strong class="font-bold">CRITICAL NOTE FOR RESEARCHERS:</strong>
            <span class="block sm:inline">This simulator models a **1D Reaction-Diffusion PDE** as an *analogue*. It is **NOT** a direct simulation of the 3D Navier-Stokes equations and cannot be used to prove or disprove the Navier-Stokes existence and smoothness conjecture. Its purpose is for conceptual understanding of related PDE phenomena.</span>
        </div>

        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Left Panel: Parameters and Controls -->
            <div class="lg:w-2/5 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md" id="parameterSection">
                <h2 class="text-2xl font-bold text-gray-700 mb-6">Simulation Parameters</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-y-6 gap-x-4 mb-8">
                    <!-- System Length -->
                    <div>
                        <label for="paramL" class="block text-sm font-medium text-gray-600" data-tooltip-content="The total spatial extent of the 1D domain for the simulation.">System Length (L):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramL" min="1" max="50" step="1" value="10" class="w-full">
                            <input type="number" id="inputL" min="1" max="50" step="1" value="10" class="w-20 p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center">
                        </div>
                    </div>
                    <!-- Grid Points -->
                    <div>
                        <label for="paramN" class="block text-sm font-medium text-gray-600" data-tooltip-content="The number of discrete points used to represent the spatial domain. Higher N means higher spatial resolution.">Grid Points (N):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramN" min="32" max="1024" step="32" value="256" class="w-full">
                            <input type="number" id="inputN" min="32" max="1024" step="32" value="256" class="w-20 p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center">
                        </div>
                    </div>
                    <!-- Total Time -->
                    <div>
                        <label for="paramT" class="block text-sm font-medium text-gray-600" data-tooltip-content="The total duration for which the simulation will run.">Total Time (T):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramT" min="0.1" max="50" step="0.5" value="5" class="w-full">
                            <input type="number" id="inputT" min="0.1" max="50" step="0.5" value="5.0" class="w-20 p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center">
                        </div>
                    </div>
                    <!-- Diffusion Coefficient -->
                    <div>
                        <label for="paramAlpha" class="block text-sm font-medium text-gray-600" data-tooltip-content="The diffusion coefficient ($\nu_{eff}$) controls how quickly the quantity $u$ spreads out from regions of high concentration to low concentration. Higher $\nu_{eff}$ leads to faster smoothing. This parameter is analogous to viscosity in fluid dynamics.">Diff. Coefficient ($\nu_{eff}$):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramAlpha" min="0.01" max="1" step="0.01" value="0.1" class="w-full">
                            <input type="number" id="inputAlpha" min="0.01" max="1" step="0.01" value="0.10" class="w-20 p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center">
                        </div>
                    </div>
                    <!-- Non-linear Growth -->
                    <div>
                        <label for="paramBeta" class="block text-sm font-medium text-gray-600" data-tooltip-content="The non-linear growth parameter ($\beta_{NL}$) influences the local growth or decay of $u$. The $u(1-u)$ term is common in logistic growth models, where growth is limited as $u$ approaches 1. This parameter represents the non-linear reaction term, conceptually similar to non-linear advection in fluid dynamics.">Non-linear Growth ($\beta_{NL}$):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramBeta" min="0" max="2" step="0.05" value="0.5" class="w-full">
                            <input type="number" id="inputBeta" min="0" max="2" step="0.05" value="0.50" class="w-20 p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center">
                        </div>
                    </div>
                    <!-- Cubic Damping -->
                    <div>
                        <label for="paramGamma" class="block text-sm font-medium text-gray-600" data-tooltip-content="The cubic damping parameter ($\gamma_{diss}$) further limits the growth of $u$, especially at higher values. It can stabilize solutions or lead to different pattern formations. This parameter represents a form of dissipation or energy removal.">Cubic Damping ($\gamma_{diss}$):</label>
                        <div class="flex items-center gap-x-3 mt-1">
                            <input type="range" id="paramGamma" min="0" max="1" step="0.01" value="0.2" class="w-full">
                            <input type="number" id="inputGamma" min="0" max="1" step="0.01" value="0.20" class="w-20 p-1 border border-gray-300 rounded-md shadow-sm text-sm text-center">
                        </div>
                    </div>
                    <!-- Initial Condition -->
                    <div class="col-span-full flex flex-col">
                        <label for="paramInit" class="text-sm font-medium text-gray-600 mb-1" data-tooltip-content="The starting profile of $u$ at time $t=0$.">Initial Condition:</label>
                        <select id="paramInit" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-base h-10">
                            <option value="gaussian">Gaussian</option>
                            <option value="step">Step</option>
                            <option value="random">Random</option>
                            <option value="sine">Sine</option>
                        </select>
                    </div>
                    <!-- Enable Tooltips Checkbox -->
                    <div class="col-span-full flex items-center mt-4">
                        <input type="checkbox" id="enableTooltips" class="form-checkbox h-4 w-4 text-indigo-600 transition duration-150 ease-in-out rounded-md">
                        <label for="enableTooltips" class="ml-2 text-sm font-medium text-gray-700" data-tooltip-content="Toggle dashboard-wide tooltips for mathematical equations and important labels. Chart hover effects are always active.">Enable Equation Tooltips</label>
                    </div>
                </div>

                <!-- Simulation Presets -->
                <div class="mt-6">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Simulation Presets:</h3>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                        <button id="presetDiffusion" class="px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10" title="Demonstrates pure diffusion">
                            Pure Diffusion
                        </button>
                        <button id="presetGrowthDecay" class="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10" title="Highlights non-linear growth and damping">
                            Growth & Decay
                        </button>
                        <button id="presetWave" class="px-4 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10" title="Visualizes a propagating wave">
                            Propagating Wave
                        </button>
                        <button id="presetPattern" class="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10" title="Shows emergent pattern formation">
                            Pattern Formation
                        </button>
                    </div>
                </div>

                <!-- Simulation Controls -->
                <h3 class="text-lg font-semibold text-gray-700 mt-6 mb-3">Simulation Controls:</h3>
                <div class="flex flex-col sm:flex-row justify-around gap-4 mb-4">
                    <button id="btnRun" class="flex-1 px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10" title="Start Simulation">
                        <span id="btnRunContent" class="flex items-center justify-center">
                            <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197 2.132A1 1 0 0110 13.82V9.18a1 1 0 011.555-.832l3.197 2.132a1 1 0 010 1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            Simulation
                        </span>
                    </button>
                    <button id="btnPauseResume" class="flex-1 px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 transition ease-in-out duration-150 opacity-50 cursor-not-allowed h-10" disabled title="Pause Simulation">
                        <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Simulation
                    </button>
                </div>
                <div class="flex flex-col sm:flex-row justify-around gap-4">
                    <button id="btnRefresh" class="flex-1 px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10" title="Refresh Dashboard">
                        <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 12c0 2.21.817 4.231 2.105 5.786M20 20v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                        Refresh
                    </button>
                    <button id="btnExport" class="flex-1 px-4 py-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition ease-in-out duration-150 opacity-50 cursor-not-allowed h-10" disabled title="Export Data">
                        <svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                        Export Data
                    </button>
                </div>
                <div class="flex justify-around gap-4 mt-4">
                    <button id="btnHelp" class="flex-1 px-4 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10 flex items-center justify-center" title="How to Interpret the Dashboard">
                        How to Interpret
                    </button>
                </div>
            </div>

            <!-- Right Panel: Live Visualization -->
            <div class="lg:w-3/5 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md relative">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-gray-700">Live Simulation <span id="liveSimSubtitle" class="ml-2 text-base font-semibold"></span></h2>
                    <div id="simulationActivityIndicator" class="hidden">
                        <span id="percentageCounter" class="text-sm font-semibold text-gray-700">0%</span>
                        <span class="spinner w-8 h-8 !border-t-green-500 !border-gray-300"></span>
                    </div>
                </div>
                <div class="progress-bar-container">
                    <div id="progressBar" class="bg-indigo-600 h-full rounded-full transition-all duration-100 ease-out" style="width: 0%;"></div>
                </div>

                <div class="relative bg-white rounded-lg p-4 shadow-inner border border-gray-300">
                    <canvas id="livePlotCanvas" class="w-full h-64 sm:h-80"></canvas>
                </div>

                <!-- NEW: Live Data Points Table -->
                <div class="mt-6 bg-white rounded-lg p-4 shadow-inner border border-gray-300">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Live Data Points</h3>

                    <!-- Simple 1-row summary (visible by default) -->
                    <div id="simpleDataTableSummary" class="mb-4 text-gray-700">
                        <p>Current $u(x,t)$ at $x=0$: <span id="summaryU0">0.0000</span></p>
                        <p>Current $u(x,t)$ at $x=L/2$: <span id="summaryUL2">0.0000</span></p>
                    </div>

                    <!-- Toggle Button -->
                    <button id="toggleDetailedTable" class="px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg shadow-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 transition ease-in-out duration-150 h-10 mb-4">
                        Show Detailed Data
                    </button>

                    <!-- Detailed Table Container (hidden by default) -->
                    <div id="detailedDataTableContainer" class="hidden">
                        <div class="mb-4">
                            <label for="tableDisplayMode" class="block text-sm font-medium text-gray-700 mb-1">Display:</label>
                            <select id="tableDisplayMode" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-base h-10">
                                <option value="u">Current Value (u)</option>
                                <option value="du_dx">First Derivative (du/dx)</option>
                                <option value="d2u_dx2">Second Derivative (d2u/dx2)</option>
                                <option value="reaction_term">Non-linear Growth Term</option>
                                <option value="damping_term">Cubic Damping Term</option>
                                <option value="du_dt">Total Rate of Change (du/dt)</option>
                            </select>
                        </div>
                        <div class="overflow-x-auto">
                            <table class="min-w-full divide-y divide-gray-200" style="table-layout: fixed;">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/2">
                                            Position (x)
                                        </th>
                                        <th id="liveTableValueHeader" scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/2">
                                            Value ($u(x,t)$)
                                        </th>
                                    </tr>
                                </thead>
                                <tbody id="liveDataTableBody" class="bg-white divide-y divide-gray-200">
                                    <!-- Rows will be dynamically inserted here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- NEW: Simulation Playback Controls -->
                <div id="playbackControls" class="mt-6 bg-white rounded-lg p-4 shadow-inner border border-gray-300 hidden">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Simulation Playback</h3>
                    <input type="range" id="playbackSlider" min="0" max="1" step="any" value="0" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span id="playbackCurrentTime">Time: 0.00s</span>
                        <span id="playbackTotalTime">Total: 0.00s</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Simulation Metrics Section -->
        <div class="mt-8 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md">
            <h2 class="text-2xl font-bold text-gray-700 mb-6">Simulation Metrics</h2>
            <div id="metricsContent" class="p-4 bg-white rounded-b-lg shadow-inner border border-gray-300">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <h3 class="font-semibold text-gray-700" data-tooltip-content="The maximum value of $u(x,t)$ observed across the spatial domain at the current time step.">Max Value ($u_{max}$):</h3>
                        <p class="text-gray-600">Current: <span id="metricMaxVal_current">0.0000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricMaxVal_max">0.0000</span></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700" data-tooltip-content="The minimum value of $u(x,t)$ observed across the spatial domain at the current time step.">Min Value ($u_{min}$):</h3>
                        <p class="text-gray-600">Current: <span id="metricMinVal_current">0.0000</span></p>
                        <p class="text-gray-600">Min Overall: <span id="metricMinVal_min">0.0000</span></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700" data-tooltip-content="The average value of $u(x,t)$ across the spatial domain at the current time step.">Mean Value ($\overline{u}$):</h3>
                        <p class="text-gray-600">Current: <span id="metricMeanVal_current">0.0000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricMeanVal_max">0.0000</span></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700" data-tooltip-content="Measures the spread or variability of $u(x,t)$ values across the domain at the current time step. Higher values indicate more spatial heterogeneity.">Standard Deviation ($\sigma_u$):</h3>
                        <p class="text-gray-600">Current: <span id="metricStdDev_current">0.0000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricStdDev_max">0.0000</span></p>
                    </div>
                    <div class="col-span-full">
                        <h3 class="font-semibold text-gray-700" data-tooltip-content="Defined as $\mathcal{E} = \int_0^L u(x,t)^2 dx$. Represents a form of 'total activity' or 'content' in the system at the current time step.">Energy ($\mathcal{E}$):</h3>
                        <p class="text-gray-600">Current: <span id="metricEnergy_current">0.0000</span></p>
                        <p class="text-gray-600">Max Overall: <span id="metricEnergy_max">0.0000</span></p>
                    </div>
                </div>
                <h3 class="font-semibold text-gray-700 mb-2">Time Series Plots:</h3>
                <div class="flex flex-col md:flex-row gap-4 mb-4">
                    <div class="w-full md:w-1/2 bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                        <canvas id="meanValChartCanvas" class="w-full h-64"></canvas>
                    </div>
                    <div class="w-full md:w-1/2 bg-gray-100 rounded-md border border-gray-300 p-2 relative">
                        <canvas id="energyChartCanvas" class="w-full h-64"></canvas>
                    </div>
                </div>

                <div class="flex flex-col items-center mt-6">
                    <div class="grid grid-cols-2 gap-4 w-full max-w-md">
                        <button id="btnResults" class="px-6 py-3 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition ease-in-out duration-150 h-10" disabled title="Interpret Current Simulation State">
                            <span class="flex items-center justify-center">
                                ✨ Results
                            </span>
                        </button>
                        <button id="btnInterpretKids" class="px-6 py-3 bg-blue-400 text-white font-semibold rounded-lg shadow-md hover:bg-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-300 focus:ring-offset-2 transition ease-in-out duration-150 h-10" disabled title="Ask Einstein for a simple explanation">
                            <span class="flex items-center justify-center">
                                ✨ Ask Einstein
                            </span>
                        </button>
                        <button id="btnQA" class="px-6 py-3 bg-orange-500 text-white font-semibold rounded-lg shadow-md hover:bg-orange-600 focus:outline-none focus:ring-2 focus:ring-orange-400 focus:ring-offset-2 transition ease-in-out duration-150 h-10" disabled title="Generate Questions & Answers">
                            <span class="flex items-center justify-center">
                                ✨ Q&A
                            </span>
                        </button>
                        <button id="btnConversation" class="px-6 py-3 bg-emerald-500 text-white font-semibold rounded-lg shadow-md hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:ring-offset-2 transition ease-in-out duration-150 h-10 flex items-center justify-center" title="Listen to a conversation about Navier-Stokes">
                            Conversation
                        </button>
                        <!-- IMPORTANT: Updated src with the new GitHub Pages audio URL -->
                        <audio id="navierStokesAudio" src="https://quantumq-ai.github.io/QQ_1D_Navier_Stokes_Conjecture_Simulator/NavierStokesConversation.mp3" preload="auto"></audio>
                    </div>
                    <div class="mt-4 w-full max-w-md">
                        <input type="text" id="geminiApiKeyInput" placeholder="Enter Gemini API Key to enable interpretation" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 text-sm text-center">
                    </div>
                </div>
            </div>
        </div>

        <!-- Tabbed Results Section (formerly the main results section) -->
        <div class="mt-8 bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-md">
            <h2 class="text-2xl font-bold text-gray-700 mb-6">Detailed Results</h2>
            <div class="flex border-b border-gray-200">
                <button id="tabFinalState" class="px-4 py-2 text-sm font-medium text-gray-600 border-b-2 border-transparent hover:border-indigo-500 focus:outline-none active:border-indigo-600 transition duration-150 ease-in-out">Final State</button>
                <button id="tabTimeEvolution" class="px-4 py-2 text-sm font-medium text-gray-600 border-b-2 border-transparent hover:border-indigo-500 focus:outline-none active:border-indigo-600 transition duration-150 ease-in-out">Time Evolution</button>
                <button id="tabAnalysis" class="px-4 py-2 text-sm font-medium text-gray-600 border-b-2 border-transparent hover:border-indigo-500 focus:outline-none active:border-indigo-600 transition duration-150 ease-in-out">Analysis & Metrics</button>
            </div>
            <div id="detailedResultsContent" class="p-4 bg-white rounded-b-lg shadow-inner border border-gray-300">
                <p class="text-gray-500 text-center py-8">Run a simulation to see results here.</p>
            </div>
        </div>
    </div>

    <!-- Modals (Help and AI Interpretation) -->
    <div id="interpretationModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">How to Read and Interpret the 1D Fluid Dynamics Analogue Simulator</h2>
            
            <h3 class="text-xl font-semibold text-gray-700 mb-2">1. Understanding this Simulator's Purpose</h3>
            <p class="mb-4 text-gray-700">
                This simulator models a **1D Reaction-Diffusion Partial Differential Equation (PDE)**, which describes how a quantity (like concentration or population density) changes over time due to diffusion and local reactions.
            </p>
            <p class="mb-4 text-gray-700">
                The equation solved by this simulator is:
                $$ \frac{\partial u}{\partial t} = \nu_{eff} \frac{\partial^2 u}{\partial x^2} + \beta_{NL} u(1-u) - \gamma_{diss} u^3 $$
                where:
                <ul class="list-disc list-inside ml-4 text-gray-700">
                    <li>$u(x,t)$ is the quantity being simulated at position $x$ and time $t$.</li>
                    <li>$\frac{\partial u}{\partial t}$ represents the rate of change of $u$ over time.</li>
                    <li>$\frac{\partial^2 u}{\partial x^2}$ represents the spatial curvature of $u$, related to diffusion.</li>
                </ul>
            </p>
            <div class="mt-4 mb-4 text-red-600 font-semibold border border-red-500 p-3 rounded-md">
                <strong class="underline">CRITICAL CLARIFICATION:</strong> This 1D Reaction-Diffusion PDE is **fundamentally different** from the 3D Navier-Stokes equations relevant to the Millennium Prize Problem. The parameters ($\nu_{eff}$, $\beta_{NL}$, $\gamma_{diss}$) in this simulator are *analogue* terms for a 1D model and do **NOT** directly correspond to the spectral index ($\alpha$), RG exponent ($\beta$), or vorticity alignment ($\cos \theta$) from the 3D Navier-Stokes regularity problem. This simulator is designed for general PDE exploration and understanding of reaction-diffusion phenomena, **not for direct verification or proof of the 3D Navier-Stokes existence and smoothness conjecture.**
            </div>

            <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">2. Simulation Parameters</h3>
            <ul class="list-disc list-inside ml-4 text-gray-700 space-y-2">
                <li><b>System Length (L):</b> The total spatial extent of the 1D domain.</li>
                <li><b>Grid Points (N):</b> The number of discrete points used to represent the spatial domain. Higher N means higher spatial resolution.</li>
                <li><b>Total Time (T):</b> The total duration for which the simulation will run.</li>
                <li><b>Diff. Coefficient ($\nu_{eff}$):</b> Controls how quickly the quantity $u$ spreads out from regions of high concentration to low concentration. Higher $\nu_{eff}$ leads to faster smoothing. This parameter is analogous to viscosity in fluid dynamics.</li>
                <li><b>Non-linear Growth ($\beta_{NL}$):</b> Influences the local growth or decay of $u$. The $u(1-u)$ term is common in logistic growth models, where growth is limited as $u$ approaches 1. This parameter represents the non-linear reaction term, conceptually similar to non-linear advection in fluid dynamics.</li>
                <li><b>Cubic Damping ($\gamma_{diss}$):</b> A cubic damping term ( $-\gamma_{diss} u^3$ ) that further limits the growth of $u$, especially at higher values. It can stabilize solutions or or lead to different pattern formations. This parameter represents a form of dissipation or energy removal.</li>
                <li><b>Initial Condition:</b> The starting profile of $u$ at time $t=0$.
                    <ul class="list-circle list-inside ml-4 mt-1">
                        <li>`Gaussian`: A bell-shaped curve, often used to simulate a localized initial perturbation.</li>
                        <li>`Step`: A profile that changes abruptly at certain points, useful for observing wave propagation or front formation.</li>
                        <li>`Random`: A noisy initial state, good for testing stability or emergent patterns.</li>
                        <li>`Sine`: A periodic wave, useful for observing how oscillations evolve.</li>
                    </ul>
                </li>
            </ul>

            <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">3. Interpreting the Results</h3>
            <ul class="list-disc list-inside ml-4 text-gray-700 space-y-2">
                <li><b>Live Simulation:</b> Shows the real-time evolution of $u(x,t)$ as the simulation progresses. Observe how the initial condition has evolved due to diffusion, reaction, and damping.</li>
                <li><b>Progress Bar:</b> Indicates the completion percentage of the simulation.</li>
                <li><b>Final State:</b> A plot of $u(x,T)$ at the very end of the simulation. This shows the stable state, oscillating pattern, or other final configuration achieved.</li>
                <li><b>Time Evolution:</b> Displays several snapshots of $u(x,t)$ at different time points throughout the simulation. This helps visualize the overall dynamic behavior.</li>
                <li><b>Analysis & Metrics:</b> Provides quantitative summaries of the final state:
                    <ul class="list-circle list-inside ml-4 mt-1">
                        <li>`Max Value`, `Min Value`, `Mean Value`, `Std Dev`: Standard statistical measures of $u$ across the spatial domain at the final time.</li>
                        <li>`Energy`: The integral of $u^2$ over the domain. This can be a useful diagnostic for stability or conservation properties in some PDE systems.</li>
                    </ul>
                </li>
                <li><b>Export Data:</b> Downloads the full simulation data (all snapshots over time) as a CSV file, which can be used for further analysis in other tools.</li>
            </ul>

            <h3 class="text-xl font-semibold text-gray-700 mb-2 mt-6">4. Exploring Dynamics</h3>
            <p class="mb-4 text-gray-700">
                By adjusting the $\nu_{eff}$, $\beta_{NL}$, and $\gamma_{diss}$ parameters, you can explore a wide range of behaviors typical for reaction-diffusion systems, such as:
                <ul class="list-disc list-inside ml-4 text-gray-700">
                    <li>Pure diffusion (set $\beta_{NL}=\gamma_{diss}=0$, vary $\nu_{eff}$).</li>
                    <li>Logistic growth (set $\nu_{eff}=\gamma_{diss}=0$, vary $\beta_{NL}$).</li>
                    <li>Pattern formation (certain combinations of $\nu_{eff}, \beta_{NL}, \gamma_{diss}$ can lead to stable spatial patterns or traveling waves).</li>
                    <li>Blow-up (though less common in this specific 1D form, extreme parameters might lead to numerical instability or very rapid growth).</li>
                </ul>
            </p>
            <p class="text-gray-700 italic">
                This tool serves as a versatile platform for understanding fundamental PDE concepts and exploring various dynamic behaviors.
            </p>
        </div>
    </div>

    <div id="aiInterpretationModal" class="modal">
        <div class="modal-content w-11/12 md:w-3/4 lg:w-1/2">
            <span class="close-button" id="closeAiInterpretationModal">&times;</span>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">✨ AI Simulation Interpretation</h2>
            <div id="aiInterpretationContent" class="text-gray-700">
                <p>Loading interpretation...</p>
                <div class="flex justify-center items-center py-8">
                    <span class="spinner w-8 h-8 !border-t-purple-500 !border-gray-200"></span>
                    <span id="aiProgressMessage" class="ml-2 text-gray-600">Generating...</span>
                </div>
            </div>
            <p class="text-sm text-gray-500 mt-4 italic">
                (Interpretation provided by Gemini LLM. It is for conceptual understanding and does not constitute formal scientific analysis.)
            </p>
        </div>
    </div>

    <!-- Dynamic Tooltip Element (Hidden by default) -->
    <div id="dynamicTooltip" class="absolute z-50 p-2 bg-gray-800 text-white text-xs rounded-md shadow-lg hidden opacity-0 transition-opacity duration-200 pointer-events-none"></div>
    
    <script type="importmap">
    {
      "imports": {
        "@google/generative-ai": "https://cdn.jsdelivr.net/npm/@google/generative-ai@0.14.0/+esm"
      }
    }
    </script>

    <script type="module">
        import { GoogleGenerativeAI } from "@google/generative-ai";

        // API Key is intentionally left as an empty string. In a Google Canvas environment,
        // the API key is injected at runtime for security. If running this code elsewhere,
        // you would need to provide a valid API key here or via another secure method.
        const API_KEY_PLACEHOLDER = ""; // This will be overridden by user input

        // ==============================================================================
        // CLASS 1: THE SIMULATION ENGINE (JavaScript Port)
        // ==============================================================================
        class ConjectureSimulator1D {
            constructor(L = 10.0, N = 256, T = 5.0, dt = 0.01,
                        nu_eff = 0.1, beta_NL = 0.5, gamma_diss = 0.2, init_cond = 'gaussian') {
                this.L = L;
                this.N = N;
                this.T = T;
                this.dt = dt;
                this.nu_eff = nu_eff;
                this.beta_NL = beta_NL;
                this.gamma_diss = gamma_diss;
                
                this.x = Array.from({ length: N }, (_, i) => (i / (N - 1)) * L);
                this.dx = this.x[1] - this.x[0];
                
                this.u = new Float64Array(N);
                this.timeSteps = [];
                this.snapshots = [];
                
                this.initializeState(init_cond);
            }

            initializeState(init_cond) {
                const center = this.L / 2;
                const width = this.L / 10;

                if (init_cond === 'gaussian') {
                    for (let i = 0; i < this.N; i++) {
                        this.u[i] = Math.exp(-Math.pow(this.x[i] - center, 2) / (2 * Math.pow(width, 2)));
                    }
                } else if (init_cond === 'step') {
                    this.u.fill(0.0);
                    for (let i = 0; i < this.N; i++) {
                        if (this.x[i] > this.L / 3) this.u[i] = 0.2;
                        if (this.x[i] > 2 * this.L / 3) this.u[i] = 0.8;
                    }
                } else if (init_cond === 'random') {
                    for (let i = 0; i < this.N; i++) {
                        this.u[i] = 0.1 * (Math.random() * 2 - 1);
                        this.u[i] = Math.max(0, Math.min(1, this.u[i]));
                    }
                } else if (init_cond === 'sine') {
                    for (let i = 0; i < this.N; i++) {
                        this.u[i] = 0.5 * (1 + Math.sin(4 * Math.PI * this.x[i] / this.L));
                    }
                }
                
                this.snapshots.push(Array.from(this.u));
                this.timeSteps.push(0.0);
            }

            // Modified to accept an optional u_array for calculations on snapshots
            diffusionTerm(u_array = this.u) {
                const u_xx = new Float64Array(this.N);
                // Central difference with periodic boundary conditions
                for (let i = 0; i < this.N; i++) {
                    const u_prev = u_array[(i - 1 + this.N) % this.N];
                    const u_next = u_array[(i + 1) % this.N];
                    u_xx[i] = (u_next - 2 * u_array[i] + u_prev) / (this.dx * this.dx);
                }
                return u_xx.map(val => this.nu_eff * val);
            }

            // Modified to accept an optional u_array for calculations on snapshots
            reactionTerm(u_array = this.u) {
                return u_array.map(val => this.beta_NL * val * (1 - val) - this.gamma_diss * Math.pow(val, 3));
            }

            step() {
                const du_dt_diff = this.diffusionTerm(); // Uses this.u by default
                const du_dt_react = this.reactionTerm(); // Uses this.u by default
                
                for (let i = 0; i < this.N; i++) {
                    this.u[i] += (du_dt_diff[i] + du_dt_react[i]) * this.dt;
                }
                for (let i = 0; i < this.N; i++) {
                    this.u[i] = Math.max(0, Math.min(1, this.u[i]));
                }
            }

            async run(progressCallback) {
                const n_steps = Math.floor(this.T / this.dt);
                const snapshot_interval = Math.max(1, Math.floor(n_steps / 100));

                for (let i = 1; i <= n_steps; i++) {
                    this.step();
                    if (i % snapshot_interval === 0 || i === n_steps) { // Ensure final state is always saved
                        this.snapshots.push(Array.from(this.u));
                        this.timeSteps.push(i * this.dt);
                    }
                    if (progressCallback) {
                        progressCallback(i / n_steps);
                    }
                    if (i % 50 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
            }

            // Modified to accept an optional u_array for calculations on snapshots
            analyzeResults(u_array = this.u) {
                const current_state = u_array;
                const max_value = Math.max(...current_state);
                const min_value = Math.min(...current_state);
                const mean_value = current_state.reduce((sum, val) => sum + val, 0) / current_state.length;
                
                const sqDiffs = current_state.map(val => Math.pow(val - mean_value, 2));
                const std_dev = Math.sqrt(sqDiffs.reduce((sum, val) => sum + val, 0) / current_state.length);

                let energy = 0;
                for (let i = 0; i < current_state.length - 1; i++) {
                    energy += (current_state[i] * current_state[i] + current_state[i+1] * current_state[i+1]) / 2 * this.dx;
                }

                return {
                    max_value,
                    min_value,
                    mean_value,
                    std_dev,
                    energy
                };
            }

            exportData() {
                let csvContent = "time," + this.x.map(val => `x_${val.toFixed(4)}`).join(",") + "\n";
                this.snapshots.forEach((snapshot, index) => {
                    const time = this.timeSteps[index].toFixed(4);
                    csvContent += `${time},${snapshot.map(val => val.toFixed(6)).join(",")}\n`;
                });

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = "simulation_results.csv";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            // NEW: Methods for derived quantities, now accepting u_array
            calculate_du_dx(u_array) {
                const du_dx = new Float64Array(this.N);
                for (let i = 0; i < this.N; i++) {
                    const u_prev = u_array[(i - 1 + this.N) % this.N];
                    const u_next = u_array[(i + 1) % this.N];
                    du_dx[i] = (u_next - u_prev) / (2 * this.dx);
                }
                return du_dx;
            }

            calculate_d2u_dx2(u_array) {
                const d2u_dx2 = new Float64Array(this.N);
                for (let i = 0; i < this.N; i++) {
                    const u_prev = u_array[(i - 1 + this.N) % this.N];
                    const u_next = u_array[(i + 1) % this.N];
                    d2u_dx2[i] = (u_next - 2 * u_array[i] + u_prev) / (this.dx * this.dx);
                }
                return d2u_dx2;
            }

            calculate_reaction_term_only(u_array) {
                return u_array.map(val => this.beta_NL * val * (1 - val));
            }

            calculate_damping_term_only(u_array) {
                return u_array.map(val => -this.gamma_diss * Math.pow(val, 3));
            }

            calculate_du_dt_total(u_array) {
                const du_dt_diff = this.diffusionTerm(u_array);
                const du_dt_react = this.reactionTerm(u_array);
                const du_dt_total = new Float64Array(this.N);
                for (let i = 0; i < this.N; i++) {
                    du_dt_total[i] = du_dt_diff[i] + du_dt_react[i];
                }
                return du_dt_total;
            }
        }

        // ==============================================================================
        // CLASS 2: THE INTERACTIVE DASHBOARD (JavaScript Port)
        // ==============================================================================
        class SimulationDashboard {
            constructor() {
                this.simulator = null;
                this.liveChart = null;
                this.finalStateChart = null;
                this.timeEvolutionChart = null;
                this.meanValChart = null; // New chart for mean value
                this.energyChart = null;   // New chart for energy
                this.currentActiveTab = 'finalState';
                this.geminiApiKey = ""; // Store the API key from the input
                this.isSimulationRunning = false; // Track simulation state
                this.isSimulationPaused = false; // Track pause state
                this.currentSimStep = 0; // Track current simulation step for progress bar
                this.currentPresetName = "Custom"; // Track the current preset name or 'Custom'
                this.currentTableDisplayMode = 'u'; // NEW: Default table display mode
                this.tooltipsEnabled = false; // NEW: State for dashboard-wide tooltips
                this.hasSimulationData = false; // NEW: Track if a simulation has been run/stopped
                this.isDetailedTableVisible = false; // NEW: State for detailed table visibility

                // Metric data
                this.meanValueHistory = [];
                this.energyHistory = [];
                this.timeLabels = [];
                this.maxMaxVal = 0;
                this.minMinVal = 1; // Assuming u is between 0 and 1
                this.maxMeanVal = 0;
                this.maxStdDev = 0;
                this.maxEnergy = 0;

                this.chartStates = {}; 

                // Initialize elements that are always present in the DOM
                this.elements = {
                    // Parameter Sliders
                    paramL: document.getElementById('paramL'),
                    paramN: document.getElementById('paramN'),
                    paramT: document.getElementById('paramT'),
                    paramAlpha: document.getElementById('paramAlpha'),
                    paramBeta: document.getElementById('paramBeta'),
                    paramGamma: document.getElementById('paramGamma'),
                    // Parameter Inputs
                    inputL: document.getElementById('inputL'),
                    inputN: document.getElementById('inputN'),
                    inputT: document.getElementById('inputT'),
                    inputAlpha: document.getElementById('inputAlpha'),
                    inputBeta: document.getElementById('inputBeta'),
                    inputGamma: document.getElementById('inputGamma'),
                    
                    paramInit: document.getElementById('paramInit'),
                    
                    btnRun: document.getElementById('btnRun'),
                    btnRunContent: document.getElementById('btnRunContent'), // Reference to the span inside btnRun
                    btnPauseResume: document.getElementById('btnPauseResume'), // New pause/resume button
                    btnRefresh: document.getElementById('btnRefresh'), // Renamed from btnReset
                    btnExport: document.getElementById('btnExport'),
                    btnHelp: document.getElementById('btnHelp'),
                    btnResults: document.getElementById('btnResults'), // Updated ID
                    btnInterpretKids: document.getElementById('btnInterpretKids'), // New kids' interpretation button
                    btnQA: document.getElementById('btnQA'), // NEW: Q&A button
                    btnConversation: document.getElementById('btnConversation'), // NEW: Conversation button
                    navierStokesAudio: document.getElementById('navierStokesAudio'), // NEW: Audio element
                    geminiApiKeyInput: document.getElementById('geminiApiKeyInput'), // API key input

                    progressBar: document.getElementById('progressBar'), 
                    livePlotCanvas: document.getElementById('livePlotCanvas'),
                    detailedResultsContent: document.getElementById('detailedResultsContent'), // Changed ID
                    tabFinalState: document.getElementById('tabFinalState'),
                    tabTimeEvolution: document.getElementById('tabTimeEvolution'),
                    tabAnalysis: document.getElementById('tabAnalysis'),
                    interpretationModal: document.getElementById('interpretationModal'),
                    closeModalButton: document.querySelector('#interpretationModal .close-button'),
                    aiInterpretationModal: document.getElementById('aiInterpretationModal'), // New AI modal
                    closeAiInterpretationModal: document.getElementById('closeAiInterpretationModal'), // New AI modal close
                    aiInterpretationContent: document.getElementById('aiInterpretationContent'), // New AI modal content
                    aiProgressMessage: document.getElementById('aiProgressMessage'), // NEW: AI progress message
                    
                    // New metric display elements
                    metricMaxVal_current: document.getElementById('metricMaxVal_current'),
                    metricMaxVal_max: document.getElementById('metricMaxVal_max'),
                    metricMinVal_current: document.getElementById('metricMinVal_current'),
                    metricMinVal_min: document.getElementById('metricMinVal_min'),
                    metricMeanVal_current: document.getElementById('metricMeanVal_current'),
                    metricMeanVal_max: document.getElementById('metricMeanVal_max'),
                    metricStdDev_current: document.getElementById('metricStdDev_current'),
                    metricStdDev_max: document.getElementById('metricStdDev_max'),
                    metricEnergy_current: document.getElementById('metricEnergy_current'),
                    metricEnergy_max: document.getElementById('metricEnergy_max'),
                    meanValChartCanvas: document.getElementById('meanValChartCanvas'),
                    energyChartCanvas: document.getElementById('energyChartCanvas'),

                    // New preset buttons
                    presetDiffusion: document.getElementById('presetDiffusion'),
                    presetGrowthDecay: document.getElementById('presetGrowthDecay'),
                    presetWave: document.getElementById('presetWave'),
                    presetPattern: document.getElementById('presetPattern'),
                    simulationActivityIndicator: document.getElementById('simulationActivityIndicator'), // New element
                    percentageCounter: document.getElementById('percentageCounter'), // New percentage counter
                    liveSimSubtitle: document.getElementById('liveSimSubtitle'), // New subtitle for live simulation panel
                    
                    // NEW: Live Data Points Table elements
                    simpleDataTableSummary: document.getElementById('simpleDataTableSummary'),
                    summaryU0: document.getElementById('summaryU0'),
                    summaryUL2: document.getElementById('summaryUL2'),
                    toggleDetailedTable: document.getElementById('toggleDetailedTable'),
                    detailedDataTableContainer: document.getElementById('detailedDataTableContainer'),
                    liveDataTableBody: document.getElementById('liveDataTableBody'), // Live data table body
                    tableDisplayMode: document.getElementById('tableDisplayMode'), // NEW: Table display mode dropdown
                    liveTableValueHeader: document.getElementById('liveTableValueHeader'), // NEW: Table header for value column
                    
                    // NEW: Playback controls
                    playbackControls: document.getElementById('playbackControls'),
                    playbackSlider: document.getElementById('playbackSlider'),
                    playbackCurrentTime: document.getElementById('playbackCurrentTime'),
                    playbackTotalTime: document.getElementById('playbackTotalTime'),

                    // NEW: Tooltip elements
                    enableTooltips: document.getElementById('enableTooltips'),
                    dynamicTooltip: document.getElementById('dynamicTooltip'),
                    mainContentArea: document.getElementById('mainContentArea') // For event delegation
                };

                // Define activateTab as an arrow function property after elements are initialized
                this.activateTab = (tabName) => {
                    [this.elements.tabFinalState, this.elements.tabTimeEvolution, this.elements.tabAnalysis].forEach(tab => {
                        tab.classList.remove('border-indigo-600', 'text-indigo-600');
                        tab.classList.add('border-transparent', 'text-gray-600');
                    });

                    // Hide all content divs
                    const finalStateWrapper = document.getElementById('finalStateWrapper');
                    const timeEvolutionWrapper = document.getElementById('timeEvolutionWrapper');
                    const analysisDiv = document.getElementById('analysisContent');

                    if (finalStateWrapper) finalStateWrapper.style.display = 'none';
                    if (timeEvolutionWrapper) timeEvolutionWrapper.style.display = 'none';
                    if (analysisDiv) analysisDiv.style.display = 'none';


                    this.currentActiveTab = tabName;
                    let targetElementForMathJax = null;

                    if (tabName === 'finalState') {
                        this.elements.tabFinalState.classList.add('border-indigo-600', 'text-indigo-600');
                        if (finalStateWrapper) {
                            finalStateWrapper.style.display = 'block';
                            targetElementForMathJax = finalStateWrapper;
                        }
                    } else if (tabName === 'timeEvolution') {
                        this.elements.tabTimeEvolution.classList.add('border-indigo-600', 'text-indigo-600');
                        if (timeEvolutionWrapper) {
                            timeEvolutionWrapper.style.display = 'block';
                            targetElementForMathJax = timeEvolutionWrapper;
                        }
                    } else if (tabName === 'analysis') {
                        this.elements.tabAnalysis.classList.add('border-indigo-600', 'text-indigo-600');
                        if (analysisDiv) {
                            analysisDiv.style.display = 'block';
                            targetElementForMathJax = analysisDiv;
                        }
                    }

                    // Re-typeset MathJax for the active tab's content
                    if (targetElementForMathJax && typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                        MathJax.typesetPromise([targetElementForMathJax]);
                    }
                };

                // Bind tooltip handlers
                this._boundHandleTooltipShow = this.handleTooltipShow.bind(this);
                this._boundHandleTooltipHide = this.handleTooltipHide.bind(this);

                this.setupEventListeners();
                this.updateAllSliderTrackColors();
                this.initializeCharts(); // Initialize live chart and metric charts
                this.resetMetricsDisplay(); // Reset metrics on load
                this.updateButtonStates(); // Set initial button states
                this.updateLiveSimulationTitle(); // Set initial title
                this.updateLiveDataTable(); // Initialize live data table
            }
            
            // NEW: Helper function to sync a slider with a number input
            setupSync(sliderId, inputId, fixedPoints = 0) {
                const slider = document.getElementById(sliderId);
                const input = document.getElementById(inputId);
                if (!slider || !input) return;

                // Event listener for slider movement
                slider.oninput = () => {
                    input.value = parseFloat(slider.value).toFixed(fixedPoints);
                    this.updateSliderTrackColor(slider);
                    this.currentPresetName = "Custom"; // Any manual change makes it custom
                    this.updateLiveSimulationTitle();
                };

                // Event listener for number input change
                input.onchange = () => { // Using onchange is better for UX than oninput for text fields
                    let value = parseFloat(input.value);
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    
                    // Validate and clamp the value
                    if (isNaN(value)) {
                        value = min;
                    }
                    value = Math.max(min, Math.min(max, value));
                    
                    // Update both slider and input to be in sync
                    slider.value = value;
                    input.value = value.toFixed(fixedPoints); // Re-format to ensure consistency
                    this.updateSliderTrackColor(slider);
                    this.currentPresetName = "Custom";
                    this.updateLiveSimulationTitle();
                };
            }

            // New helper function to update a single slider's track color
            updateSliderTrackColor(sliderElement) {
                if (!sliderElement) return;
                const value = parseFloat(sliderElement.value);
                const min = parseFloat(sliderElement.min);
                const max = parseFloat(sliderElement.max);
                const percentage = ((value - min) / (max - min)) * 100;
                sliderElement.style.setProperty('--slider-value-percent', `${percentage}%`);
            }
            
            // NEW: Helper to update all slider tracks on load
            updateAllSliderTrackColors() {
                this.updateSliderTrackColor(this.elements.paramL);
                this.updateSliderTrackColor(this.elements.paramN);
                this.updateSliderTrackColor(this.elements.paramT);
                this.updateSliderTrackColor(this.elements.paramAlpha);
                this.updateSliderTrackColor(this.elements.paramBeta);
                this.updateSliderTrackColor(this.elements.paramGamma);
            }

            setupEventListeners() {
                // Sync sliders and number inputs
                this.setupSync('paramL', 'inputL', 1);
                this.setupSync('paramN', 'inputN', 0);
                this.setupSync('paramT', 'inputT', 1);
                this.setupSync('paramAlpha', 'inputAlpha', 2);
                this.setupSync('paramBeta', 'inputBeta', 2);
                this.setupSync('paramGamma', 'inputGamma', 2);

                // Buttons
                if (this.elements.btnRun) this.elements.btnRun.onclick = () => this.handleRunStop();
                if (this.elements.btnPauseResume) this.elements.btnPauseResume.onclick = () => this.handlePauseResume();
                if (this.elements.btnRefresh) this.elements.btnRefresh.onclick = () => this.refreshApplication(false); // Explicitly reset to custom
                if (this.elements.btnExport) this.elements.btnExport.onclick = () => this.exportData();
                if (this.elements.btnHelp) this.elements.btnHelp.onclick = () => this.showModal('interpretationModal');
                if (this.elements.btnResults) this.elements.btnResults.onclick = () => this.interpretSimulationState(); // Updated ID
                if (this.elements.btnInterpretKids) this.elements.btnInterpretKids.onclick = () => this.interpretSimulationStateForKids(); // NEW: Kids' interpretation button
                if (this.elements.btnQA) this.elements.btnQA.onclick = () => this.generateQA(); // NEW: Q&A button event listener
                if (this.elements.btnConversation) this.elements.btnConversation.onclick = () => this.playConversationAudio(); // NEW: Conversation button event listener
                if (this.elements.geminiApiKeyInput) this.elements.geminiApiKeyInput.oninput = () => this.validateAndSetApiKey();

                // Tabs
                if (this.elements.tabFinalState) this.elements.tabFinalState.onclick = () => this.activateTab('finalState');
                if (this.elements.tabTimeEvolution) this.elements.tabTimeEvolution.onclick = () => this.activateTab('timeEvolution');
                if (this.elements.tabAnalysis) this.elements.tabAnalysis.onclick = () => this.activateTab('analysis');

                // Modals
                if (this.elements.closeModalButton) this.elements.closeModalButton.onclick = () => this.hideModal('interpretationModal');
                if (this.elements.closeAiInterpretationModal) this.elements.closeAiInterpretationModal.onclick = () => this.hideModal('aiInterpretationModal');
                window.onclick = (event) => {
                    if (this.elements.interpretationModal && event.target === this.elements.interpretationModal) {
                        this.hideModal('interpretationModal');
                    }
                    if (this.elements.aiInterpretationModal && event.target === this.elements.aiInterpretationModal) {
                        this.hideModal('aiInterpretationModal');
                    }
                };

                // Presets
                if (this.elements.presetDiffusion) {
                    this.elements.presetDiffusion.onclick = () => this.applyPreset({
                        name: 'Pure Diffusion', L: 10.0, N: 256, T: 10.0, nu_eff: 0.5, beta_NL: 0.0, gamma_diss: 0.0, init_cond: 'gaussian'
                    });
                }
                if (this.elements.presetGrowthDecay) {
                    this.elements.presetGrowthDecay.onclick = () => this.applyPreset({
                        name: 'Growth and Decay', L: 10.0, N: 256, T: 15.0, nu_eff: 0.01, beta_NL: 1.0, gamma_diss: 0.5, init_cond: 'random'
                    });
                }
                if (this.elements.presetWave) {
                    this.elements.presetWave.onclick = () => this.applyPreset({
                        name: 'Propagating Wave', L: 20.0, N: 512, T: 20.0, nu_eff: 0.05, beta_NL: 0.8, gamma_diss: 0.1, init_cond: 'step'
                    });
                }
                if (this.elements.presetPattern) {
                    this.elements.presetPattern.onclick = () => this.applyPreset({
                        name: 'Pattern Formation', L: 30.0, N: 768, T: 30.0, nu_eff: 0.02, beta_NL: 1.5, gamma_diss: 0.3, init_cond: 'random'
                    });
                }

                // NEW: Table display mode dropdown
                if (this.elements.tableDisplayMode) {
                    this.elements.tableDisplayMode.onchange = (event) => {
                        this.currentTableDisplayMode = event.target.value;
                        // If in playback mode, update table based on current playback snapshot
                        if (this.elements.playbackControls && !this.elements.playbackControls.classList.contains('hidden') && this.simulator) {
                            const currentTime = parseFloat(this.elements.playbackSlider.value);
                            const snapshotIndex = this.findSnapshotIndexForTime(currentTime);
                            this.updateLiveDataTable(this.simulator.snapshots[snapshotIndex]);
                        } else {
                            this.updateLiveDataTable(); // Update table content and header with current live data
                        }
                    };
                }

                // NEW: Toggle Detailed Table button
                if (this.elements.toggleDetailedTable) {
                    this.elements.toggleDetailedTable.onclick = () => this.toggleDetailedTableVisibility();
                }

                // NEW: Playback slider event listener
                if (this.elements.playbackSlider) {
                    this.elements.playbackSlider.oninput = () => this.handlePlaybackScrub();
                }

                if (this.elements.enableTooltips) {
                    // Bind the event handler to the dashboard instance
                    this.elements.enableTooltips.onchange = this.handleEnableTooltipsChange.bind(this);
                }
            }

            // NEW: Separate handler for enableTooltips change event
            handleEnableTooltipsChange(e) {
                this.tooltipsEnabled = e.target.checked;
                if (!this.tooltipsEnabled) {
                    this.handleTooltipHide(); // Hide any active tooltip if disabled
                }
            }

            // NEW: Tooltip show handler
            handleTooltipShow(event) {
                if (!this.tooltipsEnabled) return;

                const target = event.target;
                // Check if the target or its parent has a data-tooltip-content attribute
                let tooltipContent = target.dataset.tooltipContent;
                let currentElement = target;
                while (!tooltipContent && currentElement && currentElement !== this.elements.mainContentArea) {
                    currentElement = currentElement.parentElement;
                    if (currentElement) {
                        tooltipContent = currentElement.dataset.tooltipContent;
                    }
                }

                if (tooltipContent) {
                    const tooltip = this.elements.dynamicTooltip;
                    tooltip.innerHTML = tooltipContent;
                    tooltip.style.display = 'block';
                    tooltip.classList.add('show');

                    // Position the tooltip near the cursor
                    const xOffset = 10; // offset from cursor
                    const yOffset = 10; // offset from cursor

                    // Get target's position relative to the viewport
                    const targetRect = target.getBoundingClientRect();
                    
                    // Calculate tooltip position relative to the viewport
                    let tooltipX = targetRect.left + (targetRect.width / 2);
                    let tooltipY = targetRect.top;

                    // Adjust for scrolling
                    tooltip.style.left = `${tooltipX + window.scrollX}px`;
                    tooltip.style.top = `${tooltipY + window.scrollY}px`;

                    // Re-typeset MathJax for the tooltip content
                    if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                        MathJax.typesetPromise([tooltip]);
                    }
                }
            }

            // NEW: Tooltip hide handler
            handleTooltipHide() {
                const tooltip = this.elements.dynamicTooltip;
                if (tooltip) {
                    tooltip.classList.remove('show');
                    // Give it a moment to fade out before hiding completely
                    setTimeout(() => {
                        if (!tooltip.classList.contains('show')) { // Only hide if not re-shown
                            tooltip.style.display = 'none';
                            tooltip.innerHTML = ''; // Clear content
                        }
                    }, 200);
                }
            }

            applyPreset(presetConfig) {
                // Stop any running simulation first
                if (this.isSimulationRunning) {
                    this.handleRunStop(); // This will toggle it to stopped
                }

                // Set parameter values for sliders and inputs
                this.elements.paramL.value = presetConfig.L;
                this.elements.inputL.value = presetConfig.L.toFixed(1);
                
                this.elements.paramN.value = presetConfig.N;
                this.elements.inputN.value = presetConfig.N;

                this.elements.paramT.value = presetConfig.T;
                this.elements.inputT.value = presetConfig.T.toFixed(1);

                this.elements.paramAlpha.value = presetConfig.nu_eff;
                this.elements.inputAlpha.value = presetConfig.nu_eff.toFixed(2);

                this.elements.paramBeta.value = presetConfig.beta_NL;
                this.elements.inputBeta.value = presetConfig.beta_NL.toFixed(2);

                this.elements.paramGamma.value = presetConfig.gamma_diss;
                this.elements.inputGamma.value = presetConfig.gamma_diss.toFixed(2);
                
                this.elements.paramInit.value = presetConfig.init_cond;

                // Update all slider track colors
                this.updateAllSliderTrackColors();
                
                this.currentPresetName = presetConfig.name; // Set the preset name
                this.updateLiveSimulationTitle(); // Update the title immediately
                
                // Refresh the application with new parameters and start simulation
                this.refreshApplication(true); // Pass true to keep the preset name
                this.handleRunStop(); // Start the simulation
            }

            initializeCharts() {
                const chartConfigs = [
                    { id: 'livePlotCanvas', chartVar: 'liveChart', title: 'Live Simulation', yMin: -0.1, yMax: 1.2, borderColor: 'rgb(79, 70, 229)' },
                    { id: 'meanValChartCanvas', chartVar: 'meanValChart', title: 'Mean Value Over Time', yMin: 0, yMax: undefined, borderColor: '#10B981' },
                    { id: 'energyChartCanvas', chartVar: 'energyChart', title: 'Energy Over Time', yMin: 0, yMax: undefined, borderColor: '#F59E0B' }
                ];

                chartConfigs.forEach(config => {
                    const canvas = this.elements[config.id];
                    if (!canvas) {
                        console.error(`Canvas with ID ${config.id} not found! Cannot initialize chart.`);
                        return;
                    }
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error(`Could not get 2D context for canvas ${config.id}! Cannot initialize chart.`);
                        return;
                    }

                    // Destroy existing chart if it exists
                    if (this[config.chartVar]) {
                        this[config.chartVar].destroy();
                        this[config.chartVar] = null;
                    }

                    const newChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: (config.id === 'livePlotCanvas') ? (this.simulator ? this.simulator.x.map(val => val.toFixed(2)) : []) : this.timeLabels,
                            datasets: [{
                                label: (config.id === 'livePlotCanvas') ? 'u(x,t)' : config.title.replace(' Over Time', ''),
                                data: (config.id === 'livePlotCanvas') ? (this.simulator ? Array.from(this.simulator.u) : []) : (config.chartVar === 'meanValChart' ? this.meanValueHistory : this.energyHistory),
                                borderColor: config.borderColor,
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false,
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            animation: { duration: 0 },
                            scales: {
                                x: {
                                    title: { display: true, text: (config.id === 'livePlotCanvas') ? 'Position (x)' : 'Time (t)' },
                                    type: 'linear',
                                    beginAtZero: true
                                },
                                y: {
                                    title: { display: true, text: (config.id === 'livePlotCanvas') ? 'u(x,t)' : config.title.replace(' Over Time', '') },
                                    min: config.yMin,
                                    max: config.yMax,
                                    beginAtZero: true // Keep beginAtZero for mean/energy charts
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                title: { display: true, text: config.title }
                            }
                        }
                    });
                    this[config.chartVar] = newChart;
                    
                    this.chartStates[config.id] = {
                        chartInstance: newChart,
                        initialXScale: {
                            min: newChart.options.scales.x.min,
                            max: newChart.options.scales.x.max
                        },
                        initialYScale: {
                            min: newChart.options.scales.y.min,
                            max: newChart.options.scales.y.max
                        }
                    };
                });
            }

            updateMetricsDisplay(u_array = this.simulator.u, time = this.simulator.timeSteps[this.simulator.timeSteps.length - 1]) {
                if (!this.simulator) return;

                const currentResults = this.simulator.analyzeResults(u_array); // Pass u_array to analyzeResults

                if (this.isSimulationRunning && !this.isSimulationPaused) {
                    this.meanValueHistory.push(currentResults.mean_value);
                    this.energyHistory.push(currentResults.energy);
                    this.timeLabels.push(time); // Use actual time for labels
                    
                    this.maxMaxVal = Math.max(this.maxMaxVal, currentResults.max_value);
                    this.minMinVal = Math.min(this.minMinVal, currentResults.min_value);
                    this.maxMeanVal = Math.max(this.maxMeanVal, currentResults.mean_value);
                    this.maxStdDev = Math.max(this.maxStdDev, currentResults.std_dev);
                    this.maxEnergy = Math.max(this.maxEnergy, currentResults.energy);
                }


                this.elements.metricMaxVal_current.textContent = currentResults.max_value.toFixed(4);
                this.elements.metricMaxVal_max.textContent = this.maxMaxVal.toFixed(4);
                this.elements.metricMinVal_current.textContent = currentResults.min_value.toFixed(4);
                this.elements.metricMinVal_min.textContent = this.minMinVal.toFixed(4);
                this.elements.metricMeanVal_current.textContent = currentResults.mean_value.toFixed(4);
                this.elements.metricMeanVal_max.textContent = this.maxMeanVal.toFixed(4);
                this.elements.metricStdDev_current.textContent = currentResults.std_dev.toFixed(4);
                this.elements.metricStdDev_max.textContent = this.maxStdDev.toFixed(4);
                this.elements.metricEnergy_current.textContent = currentResults.energy.toFixed(4);
                this.elements.metricEnergy_max.textContent = this.maxEnergy.toFixed(4);

                this.updateCharts();
            }

            resetMetricsDisplay() {
                this.meanValueHistory = [];
                this.energyHistory = [];
                this.timeLabels = [];
                this.maxMaxVal = 0;
                this.minMinVal = 1;
                this.maxMeanVal = 0;
                this.maxStdDev = 0;
                this.maxEnergy = 0;

                ['metricMaxVal_current', 'metricMaxVal_max', 'metricMinVal_current', 'metricMinVal_min',
                 'metricMeanVal_current', 'metricMeanVal_max', 'metricStdDev_current', 'metricStdDev_max',
                 'metricEnergy_current', 'metricEnergy_max'].forEach(id => {
                    this.elements[id].textContent = '0.0000';
                });
            }

            updateCharts() {
                // Helper to get max value for Y-axis scaling with padding
                const getChartYMax = (dataArray) => {
                    if (dataArray.length === 0) return undefined;
                    const maxVal = Math.max(...dataArray);
                    return maxVal > 0 ? maxVal * 1.1 : (maxVal < 0 ? maxVal * 0.9 : 0.1);
                };

                if (this.meanValChart) {
                    this.meanValChart.data.labels = this.timeLabels;
                    this.meanValChart.data.datasets[0].data = this.meanValueHistory;
                    this.meanValChart.options.scales.y.max = getChartYMax(this.meanValueHistory);
                    this.meanValChart.update();
                }
                if (this.energyChart) {
                    this.energyChart.data.labels = this.timeLabels;
                    this.energyChart.data.datasets[0].data = this.energyHistory;
                    this.energyChart.options.scales.y.max = getChartYMax(this.energyHistory);
                    this.energyChart.update();
                }
            }

            updateButtonStates() {
                const btnRun = this.elements.btnRun;
                const btnRunContent = this.elements.btnRunContent;
                const btnPauseResume = this.elements.btnPauseResume;
                const btnRefresh = this.elements.btnRefresh;
                const btnExport = this.elements.btnExport;
                const btnResults = this.elements.btnResults; // Updated ID
                const btnInterpretKids = this.elements.btnInterpretKids;
                const btnQA = this.elements.btnQA;
                const btnConversation = this.elements.btnConversation; // NEW
                const activityIndicator = this.elements.simulationActivityIndicator;
                const spinnerElement = activityIndicator.querySelector('.spinner');
                const presetButtons = [
                    this.elements.presetDiffusion,
                    this.elements.presetGrowthDecay,
                    this.elements.presetWave,
                    this.elements.presetPattern
                ];

                const setButtonState = (btn, enabled) => {
                    if (btn) { // Ensure button exists before trying to set properties
                        btn.disabled = !enabled;
                        btn.classList.toggle('opacity-50', !enabled);
                        btn.classList.toggle('cursor-not-allowed', !enabled);
                    }
                };

                if (this.isSimulationRunning) {
                    // Simulation is actively running
                    btnRunContent.innerHTML = '<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0zM9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"></path></svg> Simulation'; // Stop symbol
                    btnRun.classList.replace('bg-indigo-600', 'bg-red-600');
                    btnRun.classList.replace('hover:bg-indigo-700', 'hover:bg-red-700');
                    btnRunContent.classList.add('pulsing-text');
                    btnRun.title = 'Stop Simulation';
                    setButtonState(btnRun, true); // Can stop
                    setButtonState(btnPauseResume, true); // Can pause/resume
                    btnPauseResume.innerHTML = '<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Simulation';
                    btnPauseResume.title = 'Pause Simulation';
                    activityIndicator.style.display = 'flex';
                    spinnerElement.classList.remove('spinner-completed');
                    setButtonState(btnExport, false); // Cannot export while running
                    setButtonState(btnResults, false); // Cannot interpret while running // Updated ID
                    setButtonState(btnInterpretKids, false);
                    setButtonState(btnQA, false);
                    setButtonState(btnConversation, true); // Conversation button can always be clicked
                    setButtonState(btnRefresh, false); // Cannot refresh while running
                    presetButtons.forEach(btn => setButtonState(btn, false)); // Disable all presets
                    if (this.elements.playbackControls) this.elements.playbackControls.classList.add('hidden'); // Hide playback controls
                    this.hasSimulationData = true; // Still running, but data is being generated
                } else if (this.isSimulationPaused) {
                    // Simulation is paused
                    setButtonState(btnRun, true); // Can stop
                    setButtonState(btnPauseResume, true); // Can resume
                    btnRunContent.classList.remove('pulsing-text');
                    btnPauseResume.innerHTML = '<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197 2.132A1 1 0 0110 13.82V9.18a1 1 0 011.555-.832l3.197 2.132a1 1 0 010 1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Simulation';
                    btnPauseResume.title = 'Resume Simulation';
                    activityIndicator.style.display = 'flex';
                    spinnerElement.classList.remove('spinner-completed');
                    setButtonState(btnExport, false); // Cannot export while paused (mid-simulation)
                    setButtonState(btnResults, false); // Cannot interpret while paused // Updated ID
                    setButtonState(btnInterpretKids, false);
                    setButtonState(btnQA, false);
                    setButtonState(btnConversation, true); // Conversation button can always be clicked
                    setButtonState(btnRefresh, false); // Cannot refresh while paused
                    presetButtons.forEach(btn => setButtonState(btn, false)); // Disable all presets
                    if (this.elements.playbackControls) this.elements.playbackControls.classList.add('hidden'); // Hide playback controls
                    this.hasSimulationData = true; // Data exists, but simulation is paused
                } else { // Simulation is stopped or completed
                    btnRunContent.innerHTML = '<svg class="inline-block w-5 h-5 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197 2.132A1 1 0 0110 13.82V9.18a1 1 0 011.555-.832l3.197 2.132a1 1 0 010 1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Simulation'; // Play symbol
                    btnRun.classList.replace('bg-red-600', 'bg-indigo-600');
                    btnRun.classList.replace('hover:bg-red-700', 'hover:bg-indigo-700');
                    btnRunContent.classList.remove('pulsing-text');
                    btnRun.title = 'Start Simulation';
                    setButtonState(btnPauseResume, false); // Cannot pause/resume if not running

                    const hasData = this.simulator && this.simulator.snapshots.length > 1;
                    const canInterpret = hasData && this.geminiApiKey.length > 0;

                    if (this.currentSimStep > 0) { // Simulation was run and either completed or stopped mid-run
                        setButtonState(btnRun, false); // Disable run button
                        setButtonState(btnExport, hasData); // Enable export if data exists
                        setButtonState(btnResults, canInterpret); // Enable interpret if data and key exist // Updated ID
                        setButtonState(btnInterpretKids, canInterpret);
                        setButtonState(btnQA, canInterpret);
                        setButtonState(btnConversation, true); // Conversation button can always be clicked
                        setButtonState(btnRefresh, true); // Always enable refresh
                        presetButtons.forEach(btn => setButtonState(btn, false)); // Disable all presets
                        activityIndicator.style.display = 'flex';
                        spinnerElement.classList.add('spinner-completed'); // Show completed spinner
                        this.elements.percentageCounter.textContent = '100%'; // Ensure 100%
                        if (this.elements.playbackControls) this.elements.playbackControls.classList.remove('hidden'); // Show playback controls
                        this.hasSimulationData = true; // Simulation has completed or stopped with data
                    } else { // Fresh state or after refresh
                        setButtonState(btnRun, true); // Enable run button
                        setButtonState(btnExport, false); // Disable export
                        setButtonState(btnResults, false); // Disable interpret // Updated ID
                        setButtonState(btnInterpretKids, false);
                        setButtonState(btnQA, false);
                        setButtonState(btnConversation, true); // Conversation button can always be clicked
                        setButtonState(btnRefresh, true); // Enable refresh
                        presetButtons.forEach(btn => setButtonState(btn, true)); // Enable all presets
                        activityIndicator.style.display = 'none'; // Hide activity indicator
                        spinnerElement.classList.remove('spinner-completed');
                        this.elements.percentageCounter.textContent = '0%'; // Reset counter
                        if (this.elements.playbackControls) this.elements.playbackControls.classList.add('hidden'); // Hide playback controls
                        this.hasSimulationData = false; // No simulation data yet
                    }
                }
            }

            async runSimulationLoop() {
                if (!this.simulator) {
                    const L = parseFloat(this.elements.paramL.value);
                    const N = parseInt(this.elements.paramN.value);
                    const T = parseFloat(this.elements.paramT.value);
                    const nu_eff = parseFloat(this.elements.paramAlpha.value);
                    const beta_NL = parseFloat(this.elements.paramBeta.value);
                    const gamma_diss = parseFloat(this.elements.paramGamma.value);
                    const init_cond = this.elements.paramInit.value;
                    this.simulator = new ConjectureSimulator1D(L, N, T, 0.01, nu_eff, beta_NL, gamma_diss, init_cond);
                }
                
                if (!this.liveChart || !this.meanValChart || !this.energyChart) {
                    this.initializeCharts();
                }

                this.isSimulationRunning = true;
                this.isSimulationPaused = false;
                this.updateButtonStates();
                this.updateLiveSimulationTitle(); // Ensure title is set when simulation starts

                this.liveChart.data.labels = this.simulator.x.map(val => val.toFixed(2));
                this.liveChart.data.datasets[0].data = Array.from(this.simulator.u);
                this.liveChart.update();
                this.updateLiveDataTable(this.simulator.u); // Initial update for the table

                const n_steps = Math.floor(this.simulator.T / this.simulator.dt);
                const snapshot_interval = Math.max(1, Math.floor(n_steps / 100));

                for (let i = this.currentSimStep + 1; i <= n_steps; i++) {
                    if (!this.isSimulationRunning) break; // Stop if simulation is stopped
                    if (this.isSimulationPaused) {
                        await new Promise(resolve => {
                            const check = () => !this.isSimulationPaused ? resolve() : requestAnimationFrame(check);
                            check();
                        });
                        if (!this.isSimulationRunning) break; // Check again after unpause
                    }

                    this.simulator.step();
                    this.currentSimStep = i;
                    
                    if (i % snapshot_interval === 0 || i === n_steps) {
                        this.simulator.snapshots.push(Array.from(this.simulator.u));
                        this.simulator.timeSteps.push(i * this.simulator.dt);
                        this.updateMetricsDisplay(this.simulator.u, i * this.simulator.dt); // Update metrics live
                    }

                    const progressPercent = (this.currentSimStep / n_steps) * 100;
                    this.elements.progressBar.style.width = `${progressPercent}%`;
                    this.elements.percentageCounter.textContent = `${progressPercent.toFixed(0)}%`; // Update percentage counter
                    this.liveChart.data.datasets[0].data = Array.from(this.simulator.u);
                    this.liveChart.update();
                    this.updateLiveDataTable(this.simulator.u); // Update the table live
                    
                    await new Promise(resolve => setTimeout(resolve, 0)); // Yield to browser to prevent UI freeze
                }

                this.isSimulationRunning = false;
                this.isSimulationPaused = false;
                this.updateMetricsDisplay(this.simulator.u, this.simulator.T); // Ensure final metrics are rendered
                this.showDetailedResults();
                this.updateButtonStates();
                this.updateLiveSimulationTitle(); // Reset title to 'Custom' or default after completion

                if (this.elements.playbackSlider && this.simulator) {
                    this.elements.playbackSlider.max = this.simulator.T;
                    this.elements.playbackSlider.value = this.simulator.T;
                    this.elements.playbackCurrentTime.textContent = `Time: ${this.simulator.T.toFixed(2)}s`;
                    this.elements.playbackTotalTime.textContent = `Total: ${this.simulator.T.toFixed(2)}s`;
                    this.updateSliderTrackColor(this.elements.playbackSlider); // Update track color
                }
            }

            handleRunStop() {
                if (this.isSimulationRunning) {
                    this.isSimulationRunning = false; // Stop the simulation
                    this.isSimulationPaused = false; // Ensure not paused if stopped
                    this.hasSimulationData = true; // Simulation stopped, but data is now available
                } else {
                    if (this.currentSimStep === 0) {
                        this.refreshApplication(true); // Pass true to keep the preset name
                    }
                    this.runSimulationLoop();
                }
                this.updateButtonStates();
            }

            handlePauseResume() {
                if (this.isSimulationRunning) {
                    this.isSimulationPaused = !this.isSimulationPaused;
                }
                this.updateButtonStates();
            }

            refreshApplication(keepPresetName = false) {
                this.isSimulationRunning = false;
                this.isSimulationPaused = false;
                this.currentSimStep = 0; // Reset simulation step
                this.elements.progressBar.style.width = '0%';
                this.elements.percentageCounter.textContent = '0%'; // Reset percentage counter
                
                if (this.liveChart) { this.liveChart.destroy(); this.liveChart = null; }
                if (this.meanValChart) { this.meanValChart.destroy(); this.meanValChart = null; }
                if (this.energyChart) { this.energyChart.destroy(); this.energyChart = null; }
                if (this.finalStateChart) { this.finalStateChart.destroy(); this.finalStateChart = null; }
                if (this.timeEvolutionChart) { this.timeEvolutionChart.destroy(); this.timeEvolutionChart = null; }

                this.chartStates = {}; 

                this.resetMetricsDisplay();
                this.simulator = null;
                this.hasSimulationData = false;
                
                if (!keepPresetName) {
                    this.currentPresetName = "Custom"; 
                }
                this.updateLiveSimulationTitle();
                
                if (this.elements.detailedResultsContent) {
                    this.elements.detailedResultsContent.innerHTML = '<p class="text-gray-500 text-center py-8">Run a simulation to see results here.</p>';
                }

                this.initializeCharts();
                
                this.updateButtonStates();

                this.updateLiveDataTable();
                this.activateTab('finalState');

                if (this.elements.playbackControls) {
                    this.elements.playbackControls.classList.add('hidden');
                    this.elements.playbackSlider.value = 0;
                    this.elements.playbackCurrentTime.textContent = 'Time: 0.00s';
                    this.elements.playbackTotalTime.textContent = '0.00s';
                }

                for (const chartId in this.chartStates) {
                    if (this.chartStates.hasOwnProperty(chartId)) {
                        const chartState = this.chartStates[chartId];
                        if (chartState.chartInstance) {
                            const chart = chartState.chartInstance;
                            if (chart.options && chart.options.scales) {
                                chart.options.scales.x.min = chartState.initialXScale.min;
                                chart.options.scales.x.max = chartState.initialXScale.max;
                                chart.options.scales.y.min = chartState.initialYScale.min;
                                chart.options.scales.y.max = chartState.initialYScale.max;
                                chart.update(); 
                            }
                        }
                    }
                }
            }

            updateLiveSimulationTitle() {
                const subtitleSpan = this.elements.liveSimSubtitle;
                if (!subtitleSpan) return;

                if (!this.isSimulationRunning && this.currentSimStep === 0) {
                    subtitleSpan.innerHTML = `<span class="text-red-600-custom">NOT ACTIVE</span>`;
                } else if (!this.isSimulationRunning && this.currentSimStep > 0 && this.elements.playbackControls && !this.elements.playbackControls.classList.contains('hidden')) {
                    const currentTime = parseFloat(this.elements.playbackSlider.value).toFixed(2);
                    subtitleSpan.innerHTML = `<span class="text-blue-600">PLAYBACK (t=${currentTime}s)</span>`;
                }
                else {
                    const presetText = this.currentPresetName.toUpperCase();
                    subtitleSpan.innerHTML = `<span class="text-green-600-custom">ACTIVE (${presetText})</span>`;
                }
            }

            toggleDetailedTableVisibility() {
                this.isDetailedTableVisible = !this.isDetailedTableVisible;
                if (this.elements.detailedDataTableContainer) {
                    this.elements.detailedDataTableContainer.classList.toggle('hidden', !this.isDetailedTableVisible);
                }
                if (this.elements.simpleDataTableSummary) {
                    this.elements.simpleDataTableSummary.classList.toggle('hidden', this.isDetailedTableVisible);
                }
                if (this.elements.toggleDetailedTable) {
                    this.elements.toggleDetailedTable.textContent = this.isDetailedTableVisible ? 'Hide Detailed Data' : 'Show Detailed Data';
                }
                if (this.isDetailedTableVisible) {
                    this.updateLiveDataTable();
                }
                if (this.elements.simpleDataTableSummary && typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                    MathJax.typesetPromise([this.elements.simpleDataTableSummary]);
                }
            }

            updateLiveDataTable(u_data = this.simulator ? this.simulator.u : null) {
                const tableBody = this.elements.liveDataTableBody;
                const valueHeader = this.elements.liveTableValueHeader;
                const summaryU0 = this.elements.summaryU0;
                const summaryUL2 = this.elements.summaryUL2;
                
                if (!summaryU0 || !summaryUL2) {
                    console.error("Summary table elements not found.");
                    return;
                }

                if (this.simulator && u_data) {
                    const u_at_0 = u_data[0];
                    const u_at_L2_index = Math.floor(this.simulator.N / 2);
                    const u_at_L2 = u_data[u_at_L2_index];
                    summaryU0.textContent = u_at_0.toFixed(4);
                    summaryUL2.textContent = u_at_L2.toFixed(4);
                } else {
                    summaryU0.textContent = '0.0000';
                    summaryUL2.textContent = '0.0000';
                }

                if (!this.isDetailedTableVisible) {
                    tableBody.innerHTML = ''; // Clear existing rows if hidden
                    valueHeader.innerHTML = 'Value ($u(x,t)$)'; // Reset header
                    if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                        MathJax.typesetPromise([valueHeader]);
                    }
                    return;
                }

                if (!tableBody || !valueHeader) {
                    console.error("Live data table elements not found.");
                    return;
                }

                tableBody.innerHTML = ''; // Clear existing rows

                if (!this.simulator || !u_data) {
                    valueHeader.innerHTML = 'Value ($u(x,t)$)'; // Reset header
                    return;
                }

                const N = this.simulator.N;
                const pointsToShow = Math.min(N, 10);
                const uniqueIndices = [];

                for (let i = 0; i < pointsToShow; i++) {
                    uniqueIndices.push(Math.floor(i * (N - 1) / (pointsToShow - 1)));
                }

                const sortedUniqueIndices = [...new Set(uniqueIndices)].sort((a, b) => a - b);

                let valuesToDisplay = [];
                let headerText = 'Value';

                switch (this.currentTableDisplayMode) {
                    case 'u':
                        valuesToDisplay = u_data;
                        headerText = 'Current Value ($u(x,t)$)';
                        break;
                    case 'du_dx':
                        valuesToDisplay = this.simulator.calculate_du_dx(u_data);
                        headerText = 'First Derivative ($\\frac{\\partial u}{\\partial x}$)';
                        break;
                    case 'd2u_dx2':
                        valuesToDisplay = this.simulator.calculate_d2u_dx2(u_data);
                        headerText = 'Second Derivative ($\\frac{\\partial^2 u}{\\partial x^2}$)';
                        break;
                    case 'reaction_term':
                        valuesToDisplay = this.simulator.calculate_reaction_term_only(u_data);
                        headerText = 'Non-linear Growth Term ($\\beta_{NL} u(1-u)$)';
                        break;
                    case 'damping_term':
                        valuesToDisplay = this.simulator.calculate_damping_term_only(u_data);
                        headerText = 'Cubic Damping Term ($-\\gamma_{diss} u^3$)';
                        break;
                    case 'du_dt':
                        valuesToDisplay = this.simulator.calculate_du_dt_total(u_data);
                        headerText = 'Total Rate of Change ($\\frac{\\partial u}{\\partial t}$)';
                        break;
                    default:
                        valuesToDisplay = u_data;
                        headerText = 'Value ($u(x,t)$)';
                }

                valueHeader.innerHTML = headerText;
                if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                    MathJax.typesetPromise([valueHeader]);
                }

                sortedUniqueIndices.forEach(idx => {
                    if (idx >= 0 && idx < N) {
                        const row = tableBody.insertRow();
                        const cellX = row.insertCell();
                        const cellVal = row.insertCell();
                        cellX.classList.add('px-6', 'py-2', 'whitespace-nowrap', 'text-sm', 'font-medium', 'text-gray-900');
                        cellVal.classList.add('px-6', 'py-2', 'whitespace-nowrap', 'text-sm', 'text-gray-500');
                        
                        cellX.textContent = this.simulator.x[idx].toFixed(2);
                        cellVal.textContent = valuesToDisplay[idx].toFixed(4);
                    }
                });
            }

            handlePlaybackScrub() {
                if (!this.simulator || this.simulator.snapshots.length === 0) return;

                const currentTime = parseFloat(this.elements.playbackSlider.value);
                this.elements.playbackCurrentTime.textContent = `Time: ${currentTime.toFixed(2)}s`;
                this.updateSliderTrackColor(this.elements.playbackSlider);

                const snapshotIndex = this.findSnapshotIndexForTime(currentTime);
                const selectedSnapshot = this.simulator.snapshots[snapshotIndex];
                const selectedTime = this.simulator.timeSteps[snapshotIndex];

                this.liveChart.data.datasets[0].data = selectedSnapshot;
                this.liveChart.update();

                this.updateLiveDataTable(selectedSnapshot);

                this.updateMetricsDisplay(selectedSnapshot, selectedTime);

                const slicedMeanHistory = this.meanValueHistory.slice(0, snapshotIndex + 1);
                const slicedEnergyHistory = this.energyHistory.slice(0, snapshotIndex + 1);
                const slicedTimeLabels = this.timeLabels.slice(0, snapshotIndex + 1);

                if (this.meanValChart) {
                    this.meanValChart.data.labels = slicedTimeLabels;
                    this.meanValChart.data.datasets[0].data = slicedMeanHistory;
                    this.meanValChart.update();
                }
                if (this.energyChart) {
                    this.energyChart.data.labels = slicedTimeLabels;
                    this.energyChart.data.datasets[0].data = slicedEnergyHistory;
                    this.energyChart.update();
                }

                this.elements.liveSimSubtitle.innerHTML = `<span class="text-blue-600">PLAYBACK (t=${selectedTime.toFixed(2)}s)</span>`;
            }

            findSnapshotIndexForTime(time) {
                if (!this.simulator || this.simulator.timeSteps.length === 0) return 0;
                
                let closestIndex = 0;
                let minDiff = Infinity;

                for (let i = 0; i < this.simulator.timeSteps.length; i++) {
                    const diff = Math.abs(this.simulator.timeSteps[i] - time);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIndex = i;
                    }
                }
                return closestIndex;
            }

            showModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.style.display = 'flex';
                    if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                        MathJax.typesetPromise([modal]);
                    }
                } else {
                    console.error(`Modal element with ID ${modalId} not found!`);
                }
            }

            hideModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.style.display = 'none';
                }
            }

            validateAndSetApiKey() {
                this.geminiApiKey = this.elements.geminiApiKeyInput.value.trim();
                this.updateButtonStates();
            }

            async interpretSimulationState() {
                this.showModal('aiInterpretationModal');
                this.elements.aiInterpretationContent.innerHTML = `
                    <div class="flex justify-center items-center py-8">
                        <span class="spinner w-8 h-8 !border-t-purple-500 !border-gray-200"></span>
                        <span id="aiProgressMessage" class="ml-2 text-gray-600">Generating interpretation...</span>
                    </div>`;
                this.elements.aiProgressMessage.textContent = "Generating interpretation...";

                const currentApiKey = this.geminiApiKey; 

                if (!currentApiKey) {
                    this.elements.aiInterpretationContent.innerHTML = `<p class="text-red-600">Error: Gemini API key is not provided. Please enter your API key in the input field below the 'Results' button.</p>`;
                    return;
                }
                if (!this.simulator || this.simulator.snapshots.length <= 1) {
                    this.elements.aiInterpretationContent.innerHTML = `<p>Please run the simulation to generate data for interpretation.</p>`;
                    return;
                }

                const genAI = new GoogleGenerativeAI(currentApiKey);
                const geminiModel = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

                const currentResults = this.simulator.analyzeResults(this.simulator.snapshots[this.simulator.snapshots.length - 1]);

                const prompt = `
                    As an expert in partial differential equations and reaction-diffusion systems, provide a conceptual interpretation of the current state of a 1D Reaction-Diffusion PDE simulation. Do not claim to solve or disprove any millennium prize problems, but explain the observed phenomena in terms of fundamental PDE behaviors.

                    Simulation Parameters:
                    - System Length (L): ${this.elements.paramL.value}
                    - Grid Points (N): ${this.elements.paramN.value}
                    - Total Time (T): ${this.elements.paramT.value}
                    - Diffusion Coefficient (nu_eff): ${this.elements.paramAlpha.value}
                    - Non-linear Growth (beta_NL): ${this.elements.paramBeta.value}
                    - Cubic Damping (gamma_diss): ${this.elements.paramGamma.value}
                    - Initial Condition: ${this.elements.paramInit.value}
                    - Simulation Progress: Current time ${this.simulator.timeSteps[this.simulator.timeSteps.length - 1].toFixed(2)} / ${this.simulator.T.toFixed(2)}

                    Current Simulation Metrics (from the final snapshot):
                    - Max Value ($u_{max}$): ${currentResults.max_value.toFixed(4)} (The highest value of u(x,t) in the domain.)
                    - Min Value ($u_{min}$): ${currentResults.min_value.toFixed(4)} (The lowest value of u(x,t) in the domain.)
                    - Mean Value ($\\overline{u}$): ${currentResults.mean_value.toFixed(4)} (The average value of u(x,t) across the domain.)
                    - Standard Deviation ($\\sigma_u$): ${currentResults.std_dev.toFixed(4)} (Measures the spatial variability of u(x,t). A higher value indicates more pronounced patterns or gradients.)
                    - Energy ($\\mathcal{E}$): ${currentResults.energy.toFixed(4)} (Represents the total "activity" or "content" of u in the system.)

                    Consider the interplay of diffusion, non-linear growth, and cubic damping. Describe:
                    - The overall behavior observed (e.g., stable steady state, propagating wave, pattern formation, decay to zero, blow-up/instability).
                    - How the initial condition has evolved.
                    - The influence of each parameter on the current state. For example, is diffusion smoothing out patterns, is non-linear growth leading to peaks, or is damping suppressing values?
                    - What the trends in Mean Value and Energy over time suggest about the system's long-term behavior or stability.

                    Format your interpretation using Markdown, including relevant PDE and reaction-diffusion terminology where appropriate, but keep it accessible for a general scientific audience. Use LaTeX for mathematical expressions where appropriate, enclosed in '$' for inline and '$$' for block equations.
                `;

                try {
                    const result = await geminiModel.generateContent(prompt);
                    const text = await result.response.text();
                    this.elements.aiInterpretationContent.innerHTML = `<div class="prose max-w-none">${text.replace(/\n/g, '<br>')}</div>`;
                    if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                        MathJax.typesetPromise([this.elements.aiInterpretationContent]);
                    }
                } catch (error) {
                    console.error("Gemini API Error:", error);
                    this.elements.aiInterpretationContent.innerHTML = `<p class="text-red-600">Failed to get AI interpretation. ${error.message}. Please ensure your API key is correct and you have network connectivity.</p>`;
                }
            }

            async interpretSimulationStateForKids() {
                this.showModal('aiInterpretationModal');
                this.elements.aiInterpretationContent.innerHTML = `
                    <div class="flex justify-center items-center py-8">
                        <span class="spinner w-8 h-8 !border-t-blue-500 !border-gray-200"></span>
                        <span id="aiProgressMessage" class="ml-2 text-gray-600">Generating Einstein's explanation...</span>
                    </div>`;
                this.elements.aiProgressMessage.textContent = "Generating Einstein's explanation...";

                const currentApiKey = this.geminiApiKey;

                if (!currentApiKey) {
                    this.elements.aiInterpretationContent.innerHTML = `<p class="text-red-600">Error: Gemini API key is not provided. Please enter your API key in the input field below the 'Results' button.</p>`;
                    return;
                }
                if (!this.simulator || this.simulator.snapshots.length <= 1) {
                    this.elements.aiInterpretationContent.innerHTML = `<p>Please run the simulation to generate data for interpretation.</p>`;
                    return;
                }

                const genAI = new GoogleGenerativeAI(currentApiKey);
                const geminiModel = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

                const currentResults = this.simulator.analyzeResults(this.simulator.snapshots[this.simulator.snapshots.length - 1]);
                const finalTime = this.simulator.timeSteps[this.simulator.timeSteps.length - 1].toFixed(2);
                const totalTime = this.simulator.T.toFixed(2);

                const prompt = `
                    Alright, imagine you're a super-smart science detective, and we've just finished running an experiment on a mysterious "goo" in a long, narrow tube. This isn't just any goo; it's a special substance whose behavior helps us understand how things spread, grow, and shrink in the real world, like how a rumor spreads through a school or how a forest fire grows and then dies down.

                    Here's what we set up for our experiment:
                    - **The Tube (System Length, L):** We used a tube that's ${this.elements.paramL.value} units long. Think of it as our investigation area.
                    - **Micro-Sections (Grid Points, N):** We divided our tube into ${this.elements.paramN.value} tiny, tiny sections. The more sections, the more detail we can see, like having super-high-resolution binoculars!
                    - **Observation Time (Total Time, T):** We watched the goo for a total of ${totalTime} seconds.
                    - **The "Spreading Agent" (Diffusion Coefficient, $\\nu_{eff}$):** This is ${this.elements.paramAlpha.value}. Imagine a clumsy student spills a drink. This number tells us how quickly that spill spreads out on its own, trying to make the goo even everywhere. A higher number means the goo is super eager to spread and smooth things out.
                    - **The "Growth Potion" (Non-linear Growth, $\\beta_{NL}$):** This is ${this.elements.paramBeta.value}. This is like a magical ingredient. If there's a little bit of goo, this potion makes more goo! But here's the catch: if there's *too much* goo, the potion gets shy and stops working as well. It's like a popular trend – it grows fast at first, but then everyone's doing it, and it slows down.
                    - **The "Clean-up Crew" (Cubic Damping, $\\gamma_{diss}$):** This is ${this.elements.paramGamma.value}. This is our clean-up crew that removes goo, especially when there's a lot of it. The more goo, the harder they work to make it disappear. They're like the school principal, stepping in to calm things down when the energy gets too wild!
                    - **The Starting Point (Initial Condition):** We started our experiment with a '${this.elements.paramInit.value}' goo setup. Was it a big blob in the middle (Gaussian), a sudden jump (Step), totally random and messy (Random), or a wavy pattern (Sine)?
                    - **Current Status:** We're currently at ${finalTime} seconds into our ${totalTime}-second observation.

                    Now, let's look at the evidence, detective! What story do these numbers tell us about our mysterious goo?

                    **The Goo's Report Card (Final Snapshot Metrics):**
                    - **Highest Goo Mountain (Max Value, $u_{max}$):** ${currentResults.max_value.toFixed(4)}. This is the tallest peak of goo we saw. If it's close to 1, our goo almost filled that spot!
                    - **Deepest Goo Valley (Min Value, $u_{min}$):** ${currentResults.min_value.toFixed(4)}. This is the lowest point of goo. If it's near 0, that spot was almost empty.
                    - **Average Goo Level (Mean Value, $\\overline{u}$):** ${currentResults.mean_value.toFixed(4)}. If we could magically flatten out all the goo evenly across the tube, this is how much goo would be everywhere.
                    - **Goo Rollercoaster (Standard Deviation, $\\sigma_u$):** ${currentResults.std_dev.toFixed(4)}. This number tells us how "bumpy" or "smooth" our goo is.
                        * If this number is big, it means the goo is like a wild rollercoaster, with big mountains and deep valleys! Lots of differences from one spot to another.
                        * If it's small, the goo is calm and flat, like a perfectly smooth road.
                    - **Total Goo Activity (Energy, $\\mathcal{E}$):** ${currentResults.energy.toFixed(4)}. Think of this as the overall "busyness" or "amount of stuff" in our goo system. If this number is growing, it means the goo is getting more active or there's more of it. If it's shrinking, the goo is calming down or disappearing.

                    **The Story of the Goo's Journey:**

                    Based on these numbers and how the "Spreading Agent," "Growth Potion," and "Clean-up Crew" worked together, here's what likely happened:

                    * **The Initial Goo:** Our experiment started with a **${this.elements.paramInit.value}** goo setup. This was our starting clue!
                    * **The Battle of Forces:**
                        * The **Spreading Agent (Diffusion)** was constantly trying to smooth out any bumps, pushing goo from crowded areas to empty ones. It's like a diligent librarian trying to put all the books back in their proper, even shelves.
                        * The **Growth Potion (Non-linear Growth)** was trying to create more goo, especially where there was a moderate amount. This is the creative force, trying to build new goo structures.
                        * The **Clean-up Crew (Cubic Damping)** was working hard to remove goo, especially when the goo mountains got too high. They're like the school principal, stepping in to calm things down when the energy gets too wild!

                    * **The Grand Finale:** Look at the "Highest Goo Mountain" and "Deepest Goo Valley." Are they close together or far apart? This tells us if the goo settled into a calm, even state, or if it formed exciting patterns. The "Goo Rollercoaster" number is key here – a high number means patterns, a low number means smooth sailing.

                    * **The Goo's Long-Term Fate:** The "Total Goo Activity" (Energy) and "Average Goo Level" (Mean Value) over time are like the goo's mood ring.
                        * If the Energy and Mean Value went up and then stayed steady, the goo found a happy balance, a "steady state" where everything is stable.
                        * If they kept going up, maybe the Growth Potion was too strong, and the goo kept growing and growing! (Though our clean-up crew usually prevents total chaos).
                        * If they went down to zero, the clean-up crew won, and the goo might have completely disappeared!

                    So, detective, what's your conclusion? Did the goo settle down, did it create amazing patterns, or did it slowly fade away? By changing the "ingredients" (our parameters), you can change the entire story of the goo! This is how scientists figure out how complex systems work, by seeing how different forces battle it out!
                `;

                try {
                    const result = await geminiModel.generateContent(prompt);
                    const text = await result.response.text();
                    this.elements.aiInterpretationContent.innerHTML = `<div class="prose max-w-none">${text.replace(/\n/g, '<br>')}</div>`;
                    if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                        MathJax.typesetPromise([this.elements.aiInterpretationContent]);
                    }
                } catch (error) {
                    console.error("Gemini API Error:", error);
                    this.elements.aiInterpretationContent.innerHTML = `<p class="text-red-600">Failed to get AI interpretation. ${error.message}. Please ensure your API key is correct and you have network connectivity.</p>`;
                }
            }

            async generateQA() {
                this.showModal('aiInterpretationModal');
                this.elements.aiInterpretationContent.innerHTML = `
                    <div class="flex justify-center items-center py-8">
                        <span class="spinner w-8 h-8 !border-t-orange-500 !border-gray-200"></span>
                        <span id="aiProgressMessage" class="ml-2 text-gray-600">Generating Q&A pairs...</span>
                    </div>`;
                this.elements.aiProgressMessage.textContent = "Generating Q&A pairs..."; // Ensure message is set

                const currentApiKey = this.geminiApiKey;

                if (!currentApiKey) {
                    this.elements.aiInterpretationContent.innerHTML = `<p class="text-red-600">Error: Gemini API key is not provided. Please enter your API key in the input field below the 'Results' button.</p>`;
                    this.elements.aiProgressMessage.textContent = "API Key missing.";
                    return;
                }
                if (!this.simulator || this.simulator.snapshots.length <= 1) {
                    this.elements.aiInterpretationContent.innerHTML = `<p>Please run the simulation to generate data for Q&A.</p>`;
                    this.elements.aiProgressMessage.textContent = "No simulation data.";
                    return;
                }

                const genAI = new GoogleGenerativeAI(currentApiKey); // Use the user-provided API key
                const geminiModel = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

                const prompt = `
                    Generate 10 unique and insightful questions with corresponding detailed answers about a 1D Reaction-Diffusion PDE simulation, framed as if for a technical or scientific reporter, mathematician, researcher, or enthusiast. The questions and answers should delve into the novel methods associated with solving such PDEs, including (but not limited to) numerical techniques like finite difference methods, the conceptual link to complex fluid dynamics (like Navier-Stokes, but *always* clarifying this 1D model is an analogue and not a direct Navier-Stokes solution), stability, convergence, and the implications of parameters.

                    Emphasize the conceptual advancements or challenges involved in approaching problems related to the Navier-Stokes existence and smoothness conjecture through methods like PINNs (Physics-Informed Neural Networks), spectral methods, finite element methods, or other advanced numerical/analytical techniques, even if this specific simulator doesn't implement them directly. The Q&A should explore the theoretical underpinnings, practical challenges, and future directions of such research.

                    The answers should be comprehensive and use appropriate scientific and mathematical terminology, including LaTeX for equations where beneficial (inline $...$ or block $$...$$).

                    Example Question/Answer Structure:
                    [
                      {
                        "question": "What is the primary purpose of a 1D Reaction-Diffusion PDE simulation in the context of complex fluid dynamics research?",
                        "answer": "A 1D Reaction-Diffusion PDE simulation serves as a simplified analogue to study fundamental phenomena observed in more complex systems, such as fluid dynamics. While not directly solving the 3D Navier-Stokes equations, it allows researchers to investigate concepts like diffusion, non-linear interactions, and pattern formation in a computationally tractable environment. This helps in building intuition and validating numerical methods that might later be applied to higher-dimensional, more intricate problems. For example, understanding the role of effective viscosity ($\\nu_{eff}$) in smoothing out gradients in 1D can provide insights into the dissipative mechanisms in turbulent flows described by Navier-Stokes."
                      },
                      {
                        "question": "How do Physics-Informed Neural Networks (PINNs) offer a novel approach to solving PDEs like the one simulated here, and what are their advantages over traditional numerical methods?",
                        "answer": "Physics-Informed Neural Networks (PINNs) represent a cutting-edge approach that integrates the governing physical laws (the PDE itself) directly into the neural network's loss function. Unlike traditional numerical methods (e.g., finite difference, finite element) that discretize the domain and solve algebraic equations at grid points, PINNs learn the solution function across the continuous domain. This offers several advantages: they can handle complex geometries and high-dimensional problems more readily, potentially reduce computational cost for certain classes of problems, and do not require mesh generation. For the reaction-diffusion equation, a PINN would attempt to minimize a loss function that includes both the residual of the PDE and the boundary/initial conditions, effectively 'learning' the solution that satisfies the physics. This is particularly relevant for problems where analytical solutions are intractable or high-fidelity numerical solutions are computationally prohibitive."
                      }
                    ]
                `;

                try {
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: prompt }] }],
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        "question": { "type": "STRING" },
                                        "answer": { "type": "STRING" }
                                    },
                                    "propertyOrdering": ["question", "answer"]
                                }
                            }
                        }
                    };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${currentApiKey}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        
                        let qaPairs;
                        try {
                            qaPairs = JSON.parse(jsonText);
                        } catch (parseError) {
                            console.error("JSON parsing error:", parseError);
                            this.elements.aiInterpretationContent.innerHTML = `<p class="text-red-600">Error: Failed to parse AI response as JSON. This might be due to an incomplete or malformed response. Please try again. (Parsing Error: ${parseError.message})</p>`;
                            this.elements.aiProgressMessage.textContent = "Parsing Error.";
                            return;
                        }

                        let qaHtml = `<h3 class="text-xl font-semibold text-gray-700 mb-4">Frequently Asked Questions</h3>`;
                        qaPairs.forEach((item, index) => {
                            qaHtml += `
                                <div class="mb-4 p-3 border border-gray-200 rounded-md bg-gray-50">
                                    <h4 class="font-bold text-lg text-gray-800 mb-1">Q${index + 1}: ${item.question}</h4>
                                    <p class="text-gray-700">${item.answer}</p>
                                </div>
                            `;
                        });
                        this.elements.aiInterpretationContent.innerHTML = `<div class="prose max-w-none">${qaHtml}</div>`;
                        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                            MathJax.typesetPromise([this.elements.aiInterpretationContent]);
                        }
                        this.elements.aiProgressMessage.textContent = "Completed.";

                    } else {
                        let errorMessage = "Failed to generate Q&A. Response structure unexpected or empty.";
                        if (result.candidates && result.candidates.length === 0) {
                            errorMessage += " No candidates found in response.";
                        } else if (result.candidates && result.candidates[0] && !result.candidates[0].content) {
                            errorMessage += " Candidate content missing.";
                        } else if (result.candidates && result.candidates[0] && result.candidates[0].content && !result.candidates[0].content.parts) {
                            errorMessage += " Candidate content parts missing.";
                        } else if (result.candidates && result.candidates[0] && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length === 0) {
                            errorMessage += " Candidate content parts empty.";
                        }
                        this.elements.aiInterpretationContent.innerHTML = `<p class="text-red-600">${errorMessage}</p>`;
                        this.elements.aiProgressMessage.textContent = "Empty/Unexpected Response.";
                    }
                } catch (error) {
                    console.error("Gemini API Error:", error);
                    this.elements.aiInterpretationContent.innerHTML = `<p class="text-red-600">Failed to get Q&A. ${error.message}. Please ensure your API key is correct and you have network connectivity.</p>`;
                    this.elements.aiProgressMessage.textContent = `API Error: ${error.message.substring(0, 30)}...`;
                }
            }

            async playConversationAudio() {
                const audio = this.elements.navierStokesAudio;
                const btnConversation = this.elements.btnConversation;

                const originalButtonContent = `Conversation`;
                const pauseButtonContent = `Pause Conversation`;
                const errorButtonContent = `Play Failed (Retry)`;

                if (audio) {
                    if (audio.paused) {
                        try {
                            await audio.play();
                            btnConversation.innerHTML = pauseButtonContent;
                        } catch (e) {
                            console.error("Error playing audio:", e);
                            btnConversation.innerHTML = errorButtonContent;
                            setTimeout(() => {
                                btnConversation.innerHTML = originalButtonContent;
                            }, 3000);
                        }
                    } else {
                        audio.pause();
                        btnConversation.innerHTML = originalButtonContent;
                    }
                }
            }

            getChartById(canvasId) {
                if (canvasId === 'livePlotCanvas') return this.liveChart;
                if (canvasId === 'finalStateChartCanvas') return this.finalStateChart;
                if (canvasId === 'timeEvolutionChartCanvas') return this.timeEvolutionChart;
                if (canvasId === 'meanValChartCanvas') return this.meanValChart;
                if (canvasId === 'energyChartCanvas') return this.energyChart;
                return null;
            }

            showDetailedResults() {
                if (!this.simulator) {
                    this.elements.detailedResultsContent.innerHTML = '<p class="text-gray-500 text-center py-8">Run a simulation to see results here.</p>';
                    return;
                }

                const finalState = this.simulator.snapshots[this.simulator.snapshots.length - 1];
                const timeSteps = this.simulator.timeSteps;
                const snapshots = this.simulator.snapshots;
                const xLabels = this.simulator.x.map(val => val.toFixed(2));

                this.elements.detailedResultsContent.innerHTML = `
                    <div id="finalStateWrapper" class="bg-gray-100 rounded-md border border-gray-300 p-2 mb-4 relative">
                        <canvas id="finalStateChartCanvas" class="w-full h-64"></canvas>
                    </div>
                    <div id="timeEvolutionWrapper" class="bg-gray-100 rounded-md border border-gray-300 p-2 mb-4 relative">
                        <canvas id="timeEvolutionChartCanvas" class="w-full h-64"></canvas>
                    </div>
                    <div id="analysisContent" class="p-4">
                        <h3 class="text-lg font-semibold text-gray-700 mb-2">Final State Metrics:</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <p class="text-gray-600" data-tooltip-content="The maximum value of $u(x,t)$ observed across the spatial domain at the final time step.">Max Value ($u_{max}$): <span id="finalMetricMaxVal">${this.elements.metricMaxVal_current.textContent}</span></p>
                                <p class="text-gray-600" data-tooltip-content="The minimum value of $u(x,t)$ observed across the spatial domain at the final time step.">Min Value ($u_{min}$): <span id="finalMetricMinVal">${this.elements.metricMinVal_current.textContent}</span></p>
                            </div>
                            <div>
                                <p class="text-gray-600" data-tooltip-content="The average value of $u(x,t)$ across the spatial domain at the final time step.">Mean Value ($\overline{u}$): <span id="finalMetricMeanVal">${this.elements.metricMeanVal_current.textContent}</span></p>
                                <p class="text-gray-600" data-tooltip-content="Measures the spread or variability of $u(x,t)$ values across the domain at the final time step. Higher values indicate more spatial heterogeneity.">Standard Deviation ($\sigma_u$): <span id="finalMetricStdDev">${this.elements.metricStdDev_current.textContent}</span></p>
                            </div>
                            <div class="col-span-full">
                                <p class="text-gray-600" data-tooltip-content="Defined as $\mathcal{E} = \int_0^L u(x,t)^2 dx$. Represents a form of 'total activity' or 'content' in the system at the final time step.">Energy ($\mathcal{E}$): <span id="finalMetricEnergy">${this.elements.metricEnergy_current.textContent}</span></p>
                            </div>
                        </div>
                    </div>
                `;

                const finalStateChartCanvas = document.getElementById('finalStateChartCanvas');
                const timeEvolutionChartCanvas = document.getElementById('timeEvolutionChartCanvas');
                const analysisDiv = document.getElementById('analysisContent');
                const finalStateWrapper = document.getElementById('finalStateWrapper');
                const timeEvolutionWrapper = document.getElementById('timeEvolutionWrapper');

                if (this.finalStateChart) { this.finalStateChart.destroy(); }
                if (this.timeEvolutionChart) { this.timeEvolutionChart.destroy(); }

                if (finalStateChartCanvas) {
                    this.finalStateChart = new Chart(finalStateChartCanvas.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: xLabels,
                            datasets: [{
                                label: 'Final State u(x,T)',
                                data: finalState,
                                borderColor: 'rgb(75, 192, 192)',
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false,
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { title: { display: true, text: 'Position (x)' } },
                                y: { title: { display: true, text: 'u(x,T)' }, min: -0.1, max: 1.2 }
                            },
                            plugins: {
                                legend: { display: false },
                                title: { display: true, text: 'Final State' }
                            }
                        }
                    });
                    this.chartStates['finalStateChartCanvas'] = {
                        chartInstance: this.finalStateChart,
                        initialXScale: { min: this.finalStateChart.options.scales.x.min, max: this.finalStateChart.options.scales.x.max },
                        initialYScale: { min: this.finalStateChart.options.scales.y.min, max: this.finalStateChart.options.scales.y.max }
                    };
                }

                if (timeEvolutionChartCanvas) {
                    const timeEvolutionDatasets = [];
                    const numSnapshotsToShow = Math.min(snapshots.length, 5);
                    const step = Math.floor(snapshots.length / numSnapshotsToShow);

                    for (let i = 0; i < numSnapshotsToShow; i++) {
                        const index = i * step;
                        if (index < snapshots.length) {
                            timeEvolutionDatasets.push({
                                label: `t = ${timeSteps[index].toFixed(2)}`,
                                data: snapshots[index],
                                borderColor: `hsl(${i * (360 / numSnapshotsToShow)}, 70%, 50%)`,
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false,
                                tension: 0.1
                            });
                        }
                    }
                    if (snapshots.length > 0 && numSnapshotsToShow < snapshots.length) {
                         timeEvolutionDatasets.push({
                            label: `t = ${timeSteps[timeSteps.length - 1].toFixed(2)} (Final)`,
                            data: snapshots[snapshots.length - 1],
                            borderColor: 'rgb(255, 99, 132)',
                            borderWidth: 3,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.1
                        });
                    }

                    this.timeEvolutionChart = new Chart(timeEvolutionChartCanvas.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: xLabels,
                            datasets: timeEvolutionDatasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { title: { display: true, text: 'Position (x)' } },
                                y: { title: { display: true, text: 'u(x,t)' }, beginAtZero: true }
                            },
                            plugins: {
                                legend: { display: true, position: 'bottom' },
                                title: { display: true, text: 'Time Evolution Snapshots' }
                            }
                        }
                    });
                    this.chartStates['timeEvolutionChartCanvas'] = {
                        chartInstance: this.timeEvolutionChart,
                        initialXScale: { min: this.timeEvolutionChart.options.scales.x.min, max: this.timeEvolutionChart.options.scales.x.max },
                        initialYScale: { min: this.timeEvolutionChart.options.scales.y.min, max: this.timeEvolutionChart.options.scales.y.max }
                    };
                }

                this.activateTab('finalState');

                if (analysisDiv && typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                    MathJax.typesetPromise([analysisDiv]);
                }
            }
        }

        // Initialize the dashboard when the DOM is fully loaded
        let dashboardInstance; // Declare a global variable for the dashboard instance
        document.addEventListener('DOMContentLoaded', () => {
            dashboardInstance = new SimulationDashboard(); // Assign the instance to the global variable
            dashboardInstance.activateTab(dashboardInstance.currentActiveTab);
        });

        // Use window.onload to ensure MathJax and all other resources are fully loaded
        window.onload = () => {
            const mainContentArea = document.getElementById('mainContentArea');
            const parameterSection = document.getElementById('parameterSection');
            const metricsContent = document.getElementById('metricsContent');
            const liveTableValueHeader = document.getElementById('liveTableValueHeader');
            const simpleDataTableSummary = document.getElementById('simpleDataTableSummary');

            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                if (mainContentArea) {
                    MathJax.typesetPromise([mainContentArea]);
                }

                setTimeout(() => {
                    if (parameterSection) {
                        MathJax.typesetPromise([parameterSection]);
                    }
                    if (metricsContent) {
                        MathJax.typesetPromise([metricsContent]);
                    }
                    if (liveTableValueHeader) {
                        MathJax.typesetPromise([liveTableValueHeader]);
                    }
                    if (simpleDataTableSummary) {
                        MathJax.typesetPromise([simpleDataTableSummary]);
                    }
                }, 200);
            } else {
                console.warn("MathJax not fully loaded or typesetPromise not available on window.onload.");
            }

            if (dashboardInstance && dashboardInstance.elements.mainContentArea) {
                dashboardInstance.elements.mainContentArea.addEventListener('mouseover', dashboardInstance._boundHandleTooltipShow);
                dashboardInstance.elements.mainContentArea.addEventListener('mouseout', dashboardInstance._boundHandleTooltipHide);
            }
        };
    </script>
</body>
</html>
